
Welcome, everyone, to this new lecture of the mobile security course. Today, we're gonna see, well, we're gonna inspect the possible techniques that you can use for reverse engineering invalid application. We will first start with, the manual inspection of a membrane application through the so called static and dynamic analysis techniques, and then we will move towards the automatic analysis of the of the of an Android application, again, through automated static analysis approach or an automated dynamic analysis approach. So first of all, we have to provide a definition formal definition of the, of what reverse engineering application means. Generally speaking, it is not possible to say, how to proceed in order to reverse engineering another application.

So reverse engineering is more or less, an art that aims towards understanding something to grab some information about how something works. So it really depends about, it really depends on the purpose and on the goal of the analysis. And according to the goal that you want to achieve and according to the information that you want to grab from the other application, you might use one possible techniques, instead of another one. So in general, we can say that, the goal of the reverse engineer is try to understand how, what is done by something, in this case, a piece of software which could be under application, and how this, action is performed and is achieved. We can say that reverse engineering is an art because there is no real guideline that you can there is no step by step guideline that you can follow, but it is more something that you really develop through the experiences.

So it is more or less an approach that is that relies on the learning by doing, methodology. So in this lecture, we will see together possible approaches that you can follow. But according to the specific scenario that you have to analyze, you will have to rely on a different set of, possible steps and approaches. So the techniques and the men the methodologies and the tools are well defined and are available, but the way you use such, this set of techniques and tools is definitely up to you, and it really depends, on the final goal that you can have in analyzing a specific application. So just to start with a possible, idea, we can discuss about this possible set of questions, which are basically the ones that usually can guide, towards the identification of a possible information.

So every time, in, like, in Android security context, the goal is the starting input comes with an APK file, which means that inside the APK file, you have the Dalvik bytecode, and you cannot inspect this. You don't have, the original source code that's shared by the developers, and you need to understand something about this application. So the possible goals could be, for example, understanding what the app does and how it does. Given that we are talking here about a security context, it is very likely that you also might need to look for possible vulnerabilities and how you can eventually exploit them. So talking about this set of possible questions, this could be, let's say, a very generic starting point that can guide you through the, through the analysis of the application itself.

So as a first step, when you are provided with an epic file, the very first goal could be to understand the generally understand what the app does. So, this could involve, installing the application on an emulator or on a real device and just run it and try to interact try to interact with it in order to understand what's the, set of functionalities provided by this, application. And the functionalities could be different between what what are the real functionalities that you can see from the app, be, with respect to the claim functionalities that are provided, for example, by the developers on the Google Play Store page. So first of all, you, like, the the very first rule is just to install the application, both in the scenario and in a real, device, and just try to interact with the application itself in order to understand what it does. Then, you can have some possible different, approaches in order to, grab some information.

So one possible way, to analyze the for analyzing an application could be to so another possible idea would be to see, for example, how you can exploit or attack a possible application. And that means that you can inspect, and you should start inspecting which are the entry points of the application, by, for example, inspecting the manifest file and then trying to understand which are the app components that you can use for, for example, to reach a specific point within the app itself. So you have to see which are the reachable the the reachable points, from, like, a different application that is installed on the same device. Or you can inspect how the the application itself interacts with other applications or with the external world, which means, if it saves any file on the on the file system or if if it relies on, for example, on network communication or intercompany intercompany communication. Then, the one possible further question that you can consider in order to inspect in another application could be to see whether it relies on a network communication.

So we could say we could assume that nowadays, mostly close, like, almost the 100% of applications, rely on the network communication because they send data over this of over, towards remote server or because they needed to download the data, data on the local device. So there are, I think, basically, very few, very few applications that nowadays do not rely on a network connection. And if this is the case, what is really interesting is to understand, for example, which, IPs, are, the target of such communication, of such interactions with, through the network. So you can inspect the IPs, the URLs that are embedded within the application, and you can see, and you can also see what is the traffic. So you might want to, for example, to sniff such traffic in order to understand why the application which data the application is sending or is receiving from, from an external source.

You can see for example, you can inspect or search for, possible private information that the application saves, generates, and, somehow uses. So if the application, for example, relies on account credentials or sensitive data like messages, photos, where are such, private info where is such private information saved on the device? And you might eventually see whether such, private information is, is even accessible by the by other apps. And, finally, you can, like, switch approach and maybe start expecting the application in order to find something that is, very specific to the app itself and that that can be exported in order to perform, a possible attack. So, we can say that, generally speaking, you should have what it's called a a top down mentality.

So you should first understand that you should, you should first have a general overview about, what the application is supposed to do, at least, as I said, according to the claims provided by the developers. And then, by first executing the application, you can start, retrieving more and more information about its functionality, its logic, its organization, and eventually explore different paths and different, portions of the app itself until you find, either vulnerability or, possible attack surface. So it really depends from the analysis that you have to do. Generally speaking, as I said, there is no way for, guide for guiding you step by step through the reverse engineering through the reverse engineering analysis of an application. It really depends on the final call.

For the purpose of this course, you will have a a set of different applications for every challenge. And or, basically, you will have several challenges, 1, each one having a single application that you will have to reverse engineer. In that case, the goal will be always the same, which is to find the the flag that I have somehow, embedded in the app. And, understanding which is the value of the flag means that you might, for example, try to understand, how a specific algorithm works or if there is a network communication with a remote server, which kind of data such application downloads from the server and so forth. So in this course, the goal will be always the same, and you might develop a specific methodology and a specific guide that you can follow, challenge after challenge.

But, for example, if you switch context and you, analyze an application for a different purpose, then the, the set of steps that you can follow could be very different. Besides that, as I said, what we can provide and what we are going to to talk in this lecture is the set of methodologies and tools that you can use for reverse engineering application. So this set of, techniques is available for anyone, and then it is up to you to decide how to use them according to your final goal. So in Android, we have 2 different, possible approaches for analyzing application, which are called static and dynamic analysis. And the concept is pretty simple.

Static analysis means that you do not run the you do not execute the application. So you start the clinical analysis application when you inspect it without, installing the app on the device and without executing it. On the other side, the dynamic analysis is complementary, and it means that, you run the application. Whether it is run on an emulator or on a real device, it doesn't really matter for the definition of dynamic analysis itself. It but the dynamic analysis involves the execution of the app.

So they are completely, complemented to each other. But, you have to rely on both for analyzing on the application. So, generally, we can say that the usual approach is to start first with a static analysis, which means that, of course, the very first step, like step 0, is installing the application and just executing it. But then when we start, when we needed to start understanding the details, the first step is to perform a static analysis. Through the static analysis, you can basically inspect the give, like, just a general overview, have a just have just a general overview about the application itself and try to respect its, its code, whether it is a small code or source code.

And then you can move towards dynamic analysis in order to, somehow validate the, functionalities and features that you expect expect from the application. So through the static analysis, at first, you, collect some possible information about the features that the, that you think the application is going to do. And then with the dynamic analysis, so with the execution of the app, you basically confirm whether the features that you expected to be, exit to be performed, with the the actions you expect that the app is going to perform are actually done or not. So static analysis is, like, it it allows you to to set up the or to identify the possible, actions, the possible functionalities of the app, and the dynamic analysis is the confirmation. But then, we could say that you you keep, going back and forth between static and dynamic analysis.

So there is no, well, generally speaking, there is no sense in relying on either static or dynamic. Every time, it is very recommended to use both, approaches unless, there are specific limitations. Or, for example, the, the exercise or the goal that you have to achieve is pretty simple so that you can just rely on a single, on a single technique. For example, for the purpose, of this course, the majority of the challenges that rely, or that require a reverse engineering approach will rely on a static analysis one. But you can also use the dynamic analysis.

When we have to switch, towards a real world scenario, like you have to really, reverse engineer another application, and nowadays, the Android apps are extremely complex, and they are getting more and more complex every day, you have that we need to rely on both approaches. So it is a matter to understand and to collect all the possible information from 1, from one technique towards the different other and then try to, somehow to match the different information that you grabbed. So starting from the static analysis, as I said, the core point is that you do not run the application. You just inspect it statically. So somehow, in the previous lecture, we already performed a sort of static analysis when I unpacked and unzipped the, DPK file.

And I started, discussing and illustrating which were the internal directories and the internal files that we could find. So, that was already an example of a static analysis. So when you have to inspect an APK file, if you have to start from scratch and maybe the application is very complex, you might start just by, like, unzipping the PK file and try to see what's inside it in order to have a for example, in the in this way, for example, you could already have some information about possible external libraries that the application relies on because you can see the associated directories, or you, for example, can check the certificate that you provided with the app itself or anything else. Like, for example, you can see, you can check whether the application has a code, which will, require a different approach for being analyzed and so forth. So by the file, at first, you can already gain some knowledge about the application itself.

Then you can perform the you can switch to a more, in-depth, static analysis, which could be inspecting the code. So you perform a disassembling procedure in order to gain and to, in order to get to the code of the application and to see, and to inspect the logic. Or you can move forward there, and you can rely on the the compilation procedure in order to see the source code of the application itself and move forward with the inspection of its internal logic. On the other side, the dynamic analysis, as I said as we said, is, kind of complementary. So it means that you execute the application.

And, in this way, you can, by executing the application, you can actually see, what is the runtime, behavior of the application itself. So for example, you can see, if there are some offoscated values, in the app, such offoscated values, for example, the IP address could be offoscated. So it could be, so the IP address that is the target of a network communication from the app towards a root server could be, which means that it is somehow replaced by a random string. And, if it is, you will not be able to, see the actual value through a static analysis approach. But when you execute the application, so through our dynamic analysis approach, the, any obfuscated value is somehow replaced with the real one because otherwise the, for example, the network communication will not work, of course.

And then you are able to see, the real value. So, somehow, the static analysis is limited and affected by obfuscation issues, where obfuscation means that, some real values are replaced with the random ones, or, for example, the, the developer chose to, somehow to hide, and replace the names of, the classes and of the methods with the random ones. So, let's say that the obfuscation is a technique used by developers in order to hide some internal functionalities and logic of their own application. And if we perform static analysis, the, obfuscation will affect this, your analysis because you will not be able to see part of the logic of the application itself. But if you perform dynamic analysis, then, whatever is, has been obfuscated will be replaced with the original real value.

And you will be able to see that during the execution of the app itself. Another possible, say, information that you can grab by the dynamic analysis is, for example, looking into the set of APIs that are invoked at runtime by an application or eventually looking into the set of system calls that are called the by an application or, let's say, starting from the set of APIs that are invoked, then you can see which other system calls are, invoked as well. And, in order to perform dynamic analysis, we basically have 2 different approaches, debugging and instrumentation. So the bagging is a general procedure. It is not part of the under the operating system because, we basically have, the bagging as a general approach for, any programming language, and it means that you, attach a debugger on top of your the process that is going to execute your application.

So it is basically and, actually, the same, like, in under in Android, you will have the same procedure as for any other, programming language. So you have a debugger. You have a process where the debugger is executed, and then you have the process where your application is executed, and the debugger is attached to, the app process. So, so that it can inspect, some possible runtime values. In the case of the debugger, the inspection works as follows.

So it assumes that the the bugger at some point stops the execution of the process where the app is running. And, we can in that case, during, like, that post state, we can expect the runtime values, for example, of some fields or of some memory. And we can, like, somehow, control the runtime execution of the application itself because we can place several breakpoints, and we can, trigger the execution step by step. So it is very useful for, understanding the general context of an application. The drawback of the debugging procedure is that, you can, rely on the backing only if you have the source code of an application.

So that is very, very, high as a as a requirement because, as I said, when you reverse engineer an application, you usually start from an APK file. So that means that if you have an APK file, you cannot actually debug the application itself. So one possible way to do that is to, decompile the full application, get the source code, and try to create a different Android project where you copy paste the source code that you have just the compiled, and you try to build a similar project, a similar application so that you can inspect it. But that is usually not a real successful procedure. So, let's say that, the packing is a useful procedure for, like, for inspecting another application, but there is this important requirement, which, rely which refers to the, access to the source code of an application.

So we cannot generally say that we can debug any other application. On the other on the other side, we have the instrumentation, which is much more, successful as a possible, as a possible technique. So the core idea or the core difference between the bugging and instrumentation is as follows. So with the debugging, you can basically, control the run time execution of an application, but the, the debugging procedure is somehow, passive. So you stop the execution of an app.

You'll see what is, what are the real values inside of the variables or in in the memory of the application itself. And then you move forward, like you you can move the execution of the app forward. On the other side, with the instrumentation, you can basically modify the runtime execution of an application. The instrumentation relies on the injection of custom code from the developer or from the reverse engineer. And this custom code can have, of course, several goals.

For example, it can, have some login functionalities, which means that you want to see which APIs are invoked. Or, for example, you want to see, which network communications are executed at run time so you can trace all the network traffic through an instrumentation. You can log all the strings, but you can also, dump and save information from the from the memory. Of course, you'll always have to find a sort of trade off between the amount of information you collect and what you are looking for because the, the more the information you get and very likely, the more difficult will be the reverse engineering task. So, as I said, what we have to keep in mind is that with the binding procedure, we just control the execution.

But, basically, like, we are not injecting new code inside the application. So we can somehow also change the runtime execution. For example, if we, modify the value, which is inside a specific, the value of a specific variable. So maybe the flow of the application could, could change, but everything is done at run time. While the instrumentation means that you somehow modify, either the execution environment of the application or even the application itself by injecting new code.

And, it is also important to keep in mind that this modification of the of the app that is provided through the instrumentation technique is not permanent. So when you rely on instrumentation and, for example, you modify the run time execution of the app, the, the let's say the modification is, alive or or, of course, as soon as the, until the application is running. As soon as you stop the execution of the app itself, the, modification is, basically lost. So between the 2 different techniques, we could say that the instrumentation is much, much more powerful, and it can also be applied to basically any application. So the bagging is a bit is, reasonable, but you need the source code while for the, instrumentation technique, you just need the EPK file.

And how does it work? Well, also in this case, there are different procedures. So it really depends on what you needed to what is your final goal. But, the standard instrumentation techniques involved in the instrumentation of the emulator of the environment, or of the app itself. So let's say that, what really, impacts or affects this choice is, the framework that you are going to rely on.

So, there are 2 possible approaches for the instrumentation. We you can manually instrument another application, or you can rely on, existing frameworks. So if you go for an existing framework, of course, you are going also to, somehow to be compliant with the design of the framework itself. So if the framework is supposed to instrument the, for example, the environment, then you are going to, to rely on, on the instrumentation of the environment. If you're going to if you're going to choose, for example, the manual instrumentation, then it is definitely up to you to identify the, the correct location of the new code that you want to inject.

Somehow, instrumentation is, we can say that this is an open problem because, even though it is very useful, there are still some issues that come with instrumentation itself, especially nowadays, because apps are getting more and more complex and also, less prone to be analyzed. So there are some techniques that are going, that are, defined as, evasion techniques that allow an application to detect whether it is running in an in an instrumented environment and eventually either change its, its own behavior at runtime or eventually, even stop its own execution. So starting from the, manual limitation, how does it work? Well, this is pretty simple. The idea is to basically get the the original file and inject some, new logic.

So this logic needs to be, providing it somehow in in a certain language, and you have 2 approaches. You can either, decompile the application, modify the source code, and then recompile the application. But this is definitely not successful because, as we have already discussed, the decompilation procedure can have some issues with the, with the resources. So I strongly recommend not to rely, on the compilation unless you need to, perform a static analysis of the app itself. So you need to inspect the source code of the application itself.

If you have to modify the application, then what you have to do is to generate or to modify the smart code of the app. So you have the original app. You can disassemble it in order to generate the smart code, and you can modify such small code. And at the end, reassemble again the application. In this case, the whole procedure, the whole approach will be always successful because if you remember, disassembling just means, to move from a compressed dybbic bytecode into an uncompressed representation.

So the, let's say the mapping between the, compressed dybbic bytecode and the uncompressed one is always 1 to 1, and the procedure is always successful. So in this case, it means that, if you disassemble an application, you modify the smarty code, eventually modifying the existing one or, inject a new one. And then you reassemble the the app. You're going to have a 100% successful procedure. If you need to inject some news money code, then the standard procedure or approach is to write, to write the the the code that you need in Java and generate the smarty code and then inject in the target application.

Constantly, the, automatic approach, as I said, there are several frameworks. And according to the framework that you're going to choose, you might want to you might have to, instrument the emulator, the Android runtime environment, or the application itself. The most famous framework that I would say, the majority of the the majority of the, version engineers relying on is called Frida. And, Frida, for example, is a framework that, performs instrumentation on top of the application itself. It relies on JavaScript.

So you basically write the code that you want to inject in JavaScript, and you inject the code into this, into the process of the application itself. So, there are some, let's say, requirements in order to perform, in order to use the free Frida framework, which are the forming ones. So it relies on, so it needs root privileges. So if you want to use Frida, you need to somehow enable, root privileges on the device. That's why, sometimes it's a little bit, it could be be a little bit annoying.

Because if you have a real device, nowadays, not all the devices could be always they can be rooted. But for example, there are Xiaomi devices that have some restrictions. Like, you have to wait for a very long amount of time in order to, to enable the root privileges and so forth. And, also, another issue that comes with this requirement is that Frida can be, actually detected. And it can be detected by the app that is, going to be instrumented.

Being detected means that, at the end of the day, the application can change its runtime behavior, and your analysis is going to be somehow compromised by such, such a detection. So, in order to have a general, let's say, overview about the, static analysis and dynamic analysis, Pros and cons. Here, we, summarize, the pros and cons of both. So starting from the static static analysis approach, we can say that this is very it's really useful when you want to have a general overview about the situation or about the set of functionalities of an app, and you want to have a high level perspective of the application itself. Then as we already said, is at some point, you need to start, focusing on specific, points, which could be interesting for your analysis, which could be, for example, the manifest file or, additional classes and logic that come with the your application itself.

And, the issue comes with, the reachable code. So as I said, with the static analysis, you can see what could be the fact what could be the functionality of an app. But since you are not executing the application itself, you cannot be really sure 100% that that functionality, that logic can be reexecuted. So you need to keep in mind that the final proof will come with the dynamic analysis. The dynamic analysis will be the final answer for you that will confirm whether a certain logic can be executed within the app itself or not.

And, eventually, you can use this, technique in order to find possible vulnerabilities. In a security context, this is extremely, sensitive. This is an extremely sensitive concept because, saying that you find the vulnerability in application approach doesn't really mean that the app is vulnerable, and that can the vulnerability can be exploited because maybe the vulnerability belongs to a portion of code that is never reachable during the execution of an app. It could be, for example, just random code that the developers left inside the application itself or that come with the library. So, with the static as I said, with the static analysis approach, you just consider possible assumptions on top of the application that you're analyzing.

Then you have to prove such assumptions with the dynamic approach. The disadvantages that come with this approach are several ones. First of all, not all the values can be expected, or not all the information can be expected within the application itself if you have, for example, obfuscation or complex algorithms. So obfuscation, as I said, means that you can have, the IPs or the URLs that are, of that are hidden or that are replaced with random values, or you can also have the source code that has been obfuscated. So that means that the, the the developers have applied the, tool that, randomizes the names of the classes and of the, of the methods itself.

I have to, highlight that you cannot obfuscate all the code. What is it is possible to be obfuscating is just the custom code of the developer. So if you have, for example, the complex algorithm that you want to keep safe from, possible reverse engineers, that it is very common from, for the developers to obfuscate such part of the application through, for example, tools like or several others. But, whatever comes with the authentication technique, then it is going to be somehow providing real value during the execution of the app itself and through the dynamic analysis technique. On the other side, there are some values some some information that are not even available.

For example, if you have, an application that relies on a network communication and downloads additional data at runtime, unless you execute the application, you will not you will never be able to access the data that are downloaded at runtime. So with the you are not able to see the network traffic. You're not able to see if, the application downloads additional code that is going to dynamically, load it at one time. So there are a set of, say, information and and data and logic that could be also part of the application itself. But given that you're not executing the application, you will not be able to see, which is the the logic of such, code itself.

Concerning the dynamic analysis technique, let's say that in this case, the positive advantages is that whatever is obfuscated in the static in a static scenario is, is replaced with real values through a dynamic analysis one. So when you execute an application, you can see everything, at run time. So it means that you can see all the IPs, all the snakes that have been obfuscated. You can see the real values for for them. So you can also dump the memory and the values of all the variables.

You can dump. You can see the network traffic. You can somehow control the internal execution of the application. So you can also change, the flow during the runtime execution, and you can expect, for example, the memory. And, usually, when when we execute an application, we can either access to some task specific values or specific files that are generated, in the device.

But we can, also, on the other side, inspect the the behavior of the app itself, which means at the end of the day, to see which APIs are involved by the app and with which arguments. And what is extremely important for security is that, as I said, if you if you find the vulnerability through a static analysis approach, you have to prove that this is an exploitable vulnerability, through a dynamic analysis one. So you can see a vulnerability, by subject and analyzing an MPK file. But then you have to run the application, and you have to execute the exploit in order to prove that that is a vulnerability that a real attacker can, rely on to damage the final user. On the other side, there are, a set of possible, concept for that come with analysis.

First of all, what is called the code coverage. So one possible issue is that, while through the static analysis, you can expect all the code. It doesn't without, referring to the what is obfuscated code and what is, like, clear code. If you have, an APK file, you have everything in your hand, and you can inspect such code, such logic. But the issue is that, you can have something that is obfuscated.

On the other side, when you perform a dynamic analysis, you may not be able to reach all the different points and, execute all the possible logic within the application itself. So for example, that could be, there could be a path that is never reachable, and you can, in the or a specific point that you can cannot reach. And, this is extremely important as a possible side effect that comes with the dynamic analysis because you will never be able to so nowadays, there are no tools that guarantee 100% code coverage. So you will never be able to say that, you exit you, evaluated the the whole code of an application. Another possible disadvantage that comes with dynamic analysis is that you sometimes don't have the context, which means that during the execution, you might not be able to see what is the surrounding environment of the application itself.

So, for example, executing an application in an emulator, where like, through an automatic approach or even manually, but in a context that is just an emulation of hardwell device and without, for example, other application running in the background and so forth, is not, the real worst scenario where the application can be executed if it is a malicious one. So let's say the dynamic analysis is also affected by the context, with which you analyze and execute the application itself, which could be different from a real world scenario. Finally, dynamic analysis techniques can be somehow evaded. Evaded means that the app can understand when it is under analysis and eventually bypass the the execution the the analysis itself. So so far, the techniques that I have just introduced are, techniques that can be used manually.

So, whether you perform a manual inspection or you rely on a framework, what is done is done, step by step by the by the the reverse engineer itself. There is a further step in the way you can analyze an application, which is called the program analysis that, relies on making both state static and dynamic analysis approaches automatic. So, for example, the, if we think about the, possibly the main goal that, bus engineer can have in inspecting another application could be to find the malware or, bugs, security issues within an application itself. And generally speaking, the, let's say that the possible first step could be to rely on a manual approach. But the final goal of all the reverse engineer engineers is to have something that runs automatically.

So, this is extremely important because, nowadays, we have, a huge number of applications. And there are not not enough reverse, engineers that can handle such, such task. So, on the Google Play Stores, we can find more than 3,000,000 applications. And on the Apple Store, we can find even more than 1.8 applications. And on the Apple Store, we can find even more than 1,800,000.

And it is pretty impossible for, all the, like, all the human reverse engineers to, manually analyze all the applications. So what happens on the other side is that we can move a step forward and improve the way we can analyze an application by providing an automatic approach. Automatic approach means that we basically switch from what is called a manual static analysis and the manual, dynamic analysis techniques towards something that is automatic. Of course, switching from a manual approach towards an automatic one introduces a set of new challenges. So let's say that when we talk about static analysis, the manual approach could, for example, involve statically reverse engineering application or, unzipping or unpacking the APK file and trying to respect, step by step all the source code or the code within the application itself.

On the other side, trying to make this, procedure automatic means that you try to, like, somehow to build a a problem that is able to, of course, to replace a human being, and it, and that can search for specific information, which could be, expecting the payload of an application or searching for specific signatures, which means, for example, checking for specific, for a specific sequence of APIs that are called or, performing some specific checks on top of the, application itself. And there are, 2 further possible techniques that can be used for performing an automatic static analysis, which are called the tracking and symbolic execution. On the other side, when we switch from a manual analysis approach in a dynamic, scenario towards an automatic one, we have different challenges too. So, dynamic analysis through a manual approach means that you just, execute, install the application, and then execute it, and, eventually, in an instrumented environment or by the banking application. Moving towards an automatic approach means that you, have to emulate what you do by your hands.

So, if you if dynamic, dynamic analyzing an application means that you install an app and you click on the screen, when you switch to an automatic approach, it means that you have to somehow, to rely on a program that can emulate the user and click on the screen as if it was the user. And, this is definitely not so easy because the logic according to which you move or you choose the, like, the the graphical element that you want to click inside the application itself could be very, could affect the, the path and the, let's say, the the the digital execution part of the application itself. Generally speaking, the program analysis goals could be, the following ones. So the majority, let's say, most of the times, the main goal is to find malware. So, we also have to think about, for example, the Google Play Store, the amount of application that we have on the Google Play Store.

And we cannot assume that we that there are some human beings that work as reverse engineers and that manually inspect all the different applications. So the, security evaluation of such application is performed through, automatic, static, and dynamic, approaches. And, eventually, another so let's say the first step, the first goal could be malware detection. The second one could be vulnerability scanning and also, exploitation and eventually fetching. So everything moves around the, say, security evaluation of an application itself.

And, in the first case, when we talk about malware, we can have, it means that we need to understand and to identify malicious behavior that are, developed on purpose by the attackers, while in case of vulnerabilities and, and eventually, exploits, We are talking about, possible issues, security issues that have been introduced by the developers of an application, not on purpose. So, for example, just, because they were not aware of a specific security issue or for several other reasons. So when we have, when we talk about the static program analysis, which means like, you making the static analysis approach automatic, we have a set of common, steps that can be achieved. So once again, the app is never executed. But what we can do through an automatic approach is that we can evaluate all the possible path within the application itself.

Because as we said, we have an epic file, and we can then compile it and access to all the possible path paths that are within the application itself. When we, while we expect all the code, we have to keep in mind or to say somehow the, significant information that are embedding the application itself. And significant really depends from the context and also from the final goal that you want to achieve. So some possible examples of, questions that can guide your analysis could be, you can start, for example, by searching for a specific functionality within the application itself, and, you can see that functionality through a static analysis approach. But then you will have to prove that that functionality is is really executed through a dynamic approach.

Or, you can, for example, find, something, like you are searching for functionality and you, do not see, in the application itself through a static approach, but then you have to analyze, through a dynamic approach the application in order to see if it really never happens also at one time. So when we talk about, static analysis, it is very useful to identify what are called the invariants, which are basically a set of properties that, are always provided and performed when an application is run. So an invariant is a feature of the application. It's a function of the application that I identified the astrostatical analysis approach, and that is also, executed when we, run the application at runtime. So, let's say the, set of possible approaches through which we can rely, for which, through which we can rely for performing automatic static analysis can be different ones.

So there are, let's say the first quick analysis could be, for example, to, see specific files within the application itself. And this is the case of inspection of the manifest file or, inspection of the set of APIs that are called by the application itself or, for example, for, if we are looking for specific signatures. Yara, for example, is a tool that is very useful for, identifying and defining, better saying, for defining specific rules, which need to be, somehow, double checked and evaluated at run time by, the tool itself. The output is also, at the end, is presented to the analyst, and you can eventually also rely on machine learning techniques in order to automatically confirm the existence or, try, like, identifying some conclusions on top of the on top of the behavior that has been, found through the automated static program analysis. So when we talk about automatic static analysis procedure, there are a couple of 2, different approaches, which are the tint analysis and the symbolic execution.

So the detail of the tint analysis is the as follows. When you, when you have an APK file, you basically, try to inspect and to see all the possible parts within the APK file. And, the tint analysis is is mainly designed to to trace the usage of sensitive information within the application itself. So the idea is that with the taint analysis, you mark a possible source of sensitive data, and then you see and you then you define what is called the the the sync of the, tainted information. So data analysis is mainly designed to see if any sensitive information is, moving through different classes, objects to be in the application itself, and, what is the overall usage of such information.

So you go through the application itself. You take any sensitive data that you want to, to trace, and then, you propagate the the data from from the source to the sync point. So one possible taint information could be, for example, the location that is, sensitive. So one, use case scenario of the taint analysis could be to mark to taint the location information and then to see whether such information is propagated or shared among different components and objects within the application itself. So, media, as I said, is to see, how the the data are shared among different components and objects within the application itself.

So use case scenario is, for example, to is a, could could be to to see whether the location information is shared in a in a network of communications. So you, define what are called the sources, which could be all the location related APIs. So this is the, like, the the location within the app itself where the sensitive data is generated. And then you have the sinks, which are the, like, the endpoint. In this case, it could be the old network related APIs.

So you want to see, at the end of the day, whether the location data is sent through a network connection. So you identify you start taking the data from the source, location API related, relocation related APIs, and then you identify the, the endpoint, which in this case is the network communication. A very famous and popular tool for performing static event analysis is, FlowDroid, and we we will have a demo in the next lectures. On the other side, the, another interesting technique that is part that is more or less borderline because some researchers consider it as a static analysis approach, Some others has a dynamic one. It is not very clear.

Let's say that formally, through the symbolic execution, you are not executing the application itself, but somehow you emulate the execution of the app. So, the idea in this case is that you basically try to, build a model that mathematically represented the, the logic of the application. So once again, you have an APK file, and you try to inspect all the possible paths within the application itself. But the focus in this case is to keep track of the different values, of the variables. So when you have real values, you just save such values, in this model.

But when you have, values for which, for example variables for which the the the value is not, hard coded in the application, for example, it could be, the outcome of, of an operation or, for example, an input of, provided by user and several other cases, then you, represent such variable as, such value as a variable through this the so called symbol. So in this case, you keep, you keep moving on in this, actually, in the evaluation of the application itself in order to build a complex model that is going to, represent the logic of the application. So just to give you an example, the symbolic execution is very popular. For example, if you have, a conditional statement. So you might want to to understand whether there is a path and, or to expect specific path, and, you want to understand what is the, value that can, bring you towards a specific path, instead of another one.

Then the value is somehow abstract. So you there is no real hard coded value in the application, and you represent that value as a variable. That variable could be, could assume, like, the fixed set of possible values, which you have, of course, to determine by assumption. But then you can, achieve a high level representation of the logic of the application saying, for example, at this point, we have a variable x. And if x has this value, then we go towards this path.

If x has a different value, we can go to a different path. So this is a possible example for this symbolic execution, and the other one could be, or could refer towards the possible arguments that an API, can be invoked with. So even in the vocation of of an API, we could have a different set of arguments, and such arguments can eventually, lead to a different set of path, in the application itself. So since, through the static analysis, we, are not we are not able or let's say, when we inspect an application, we are not able to say which value, could be provided as an argument. We just symbolically represented that argument as a variable, and we, define some constraints constraints on top of the variable saying which values that variable can assume.

And we model the logic and execution path of the application according to the possible values that such variable can assume. So the symbolic execution is a very powerful technique, which basically allows you to define which inputs can somehow guide or change the execution path of an application. As I said, these are like a borderline, evaluation technique because, somehow, you're not really evaluating the application, but you you are emulating the execution of the app itself. So, it is like in the middle between static and dynamic approaches. It is very powerful, but it comes with, some issues, which are the basically, the state explosion.

So, the symbolic execution takes quite usually a lot of time and print analysis too. And, if the application is too complex, it is, generally, it is more prone to, to errors or to an infinite amount of time to like, for completing the evaluation of the application itself. Generally speaking, the all the possible, all such techniques that come with the automatic static analysis approach, have a common issue, which is that you have every time to find a trade off between scalability and precision, where, scalability, of course, means, the amount and the number of applications that you wanted to analyze. And on the other side, precision is just the ratio between the false positives and the false negatives. In the case, the false positive could be, the following case.

So, we say that, an application is, able to perform a specific action while this never happens at runtime. While on the other side, thinking about false negative, we could say that the possible use case scenario could be that we assume that an application never does something, while when we execute, these behaviors actually, seen in the application itself. So the issue is that, generally speaking, if you want to achieve scalability, it means that you, cannot have a, like, a time consuming task or a time consuming evaluation of an app. So scalability means that you, you you rely on a methodology that allows you to quickly analyze an application, which also means that it, collects, a little information about, the application itself. So if you wanted to achieve scalability, so you want to have a methodology that, analyzes a lot of applications, it means that the methodology needs to be faster.

And, if it achieves a high scalability, it means that it lose in terms of precision. Because the fewer information you the less information you have, the, lower will be the precision. On the other side, the higher is the amount of information that you collected, the higher will be the precision because you have a lot of information to be analyzed and processed. But, of course, if you want to achieve a higher precision, it means that the the methodology you are relying on will require a lot of time for analyzing a single application. That means that you will not be able to achieve, a high scalability, a high scalability.

So, all the possible approaches, whether it is when we when we are talking about an automatic approach, an automatic procedure need to be somehow fine tuned in order to find a trade off between the scalability and the precision. And there is no, like, wrong or right answer. The final choice depends on what you need to do. So, for example, if you need to analyze, 1,000 apps in a very, tighter time frame, then you might go for, like, for methodology that requires, less time. On the other side, if you needed to, identify a very specific feature and you, for example, need to analyze very few apps, then you might go for something, that could be highly precise.

Another possible problem that comes with the static analysis is the evasion. So, evasion, of course, whenever a malicious application wants to hide his or malicious behaviors when it is, evaluated through a static, or even through a dynamic analysis approach. So, evasion could be possible examples of evasions, could be, for example, the usage of reflection, which prevents the, like, which makes you really, really hard to understand which APIs are invoked by an API, by an application, or, for example, the dynamic code loading, which means that unless you execute the application, you will never be able to see which additional code is the is the, dynamically loaded at runtime. Or, single, which means that, all the strings are replaced with random values or even native code because native code, which means, a CNC plus plus code is something that is usually not traced by the existing tools. So all such techniques are called the, evasion techniques because they are used by malicious attackers, by malicious developers in order to bypass the detection through the or the analysis through a static analysis approach.

And, not all of them are solvable because, the tools that we have today are actually impacted by such techniques, and they are limited by such techniques. So it is actually not possible to to prevent, a malware from using such techniques to to evade the, the analysis. So a possible solution could be also in the case of an automatic approach to rely on both the automatic static approach and the automatic dynamic approach. So talking about the dynamic approach, dynamic, automatic dynamic analysis. In this case, let's say that the switch from the manual approach towards the automatic one mainly focuses on, the usage of tools that can emulate the the physical user.

So, once again, the assumption is that we have to execute the application and that, when we have to execute the path, the application will usually follow a single path. So, we have somehow to make to make some choices in order to, to evaluate all the possible parts that we can as man as many parts that we can do, under the assumption that the code coverage will never be a 100%. So, honestly, again, even in the automatic approach, we will never be sure that we are have executed the, the whole application. There will be, for sure, some logic that is not possible to be, to be executed. So, in this case, we have, we can have an we can have an instrumented environment.

But, what really, makes the switch from a manual towards an automatic approach is the usage of something that, emulates the user with an automatic interaction with the graphical user with the activities of the app itself. So, some possible questions that can drive, an automatic dynamic analysis could be, for example, to double check whether something that we have found through a static analysis are actually is actually performed at one time. So if we found that x can happen through static analysis, then, we really need to, to prove that x is, actually, performed at one time. And on the other way, if we are sure, that something, for example, x never happens for a static analysis, we need to prove that with the dynamic one. Similarly to the, like, to the manual approach, of course, in the automatic dynamic analysis, we can have access to the file system, to the network traffic, to the we can see everything because it needs no obfuscation.

The main limitation comes with the code coverage. So, when we switch to an automatic approach, we basically rely on the same set of techniques. So once again, the bagging and instrumentation, where instrumentation means, environment, environment instrumentation, but also repackaging or, let's say, relying on existing frameworks such as EXPOS and Freedom. On the other side, we have to, as I said, we have to emulate the user. And for this purpose, we can rely, for example, on tools such as monkey runner or UI Automator, which are examples of tools that so those are usually the building blocks on top of which we can rely for an automatic dynamic analysis.

Also, in this case, we have some issues. First of all, we again have the limited code coverage, which means that we'll never have an application that will be executed in all its parts. So there are some, possible, portion of the app that will never be reached. So we can, we might not be be enabled for, to evaluate some portions of the application. And it is also pretty impossible to explore the whole logic of the application itself because it is not possible to cover all the possible parts.

So some possible questions that are very hard to be answered are, for example, how can I reach that point x by clicking on the map buttons, or which are the conditions that I can use for reaching that point, or which kind of environment I should should set up in order to reach or to execute that specific logic in the application itself? A second issue that also affects the dynamic analysis is the evasion. So once again, the applications can, might want to hide the thermal issues behavior by, using EBD techniques that affect the dynamic analysis. So code coverage in this case, is somehow exploited by the attackers because they try to build, some conditions so that can never be satisfied, understand, under, some assumptions so that when you execute an application, you will be never able to reach that point unless some other conditions are satisfied. So the difficult to satisfy conditions are very common and useful for, the malware so that, for example, you execute the app in an emulator, and you will never see the malicious behavior.

But if you execute to the same application in a real device, then you will see a different behavior. And, the final goal, of course, is to hide the diminishes behavior so that the automatic dynamic approach will never trigger or will never detect the, that the application is a malware. Generally speaking, these conditions are called bumps. So you can have, the bombs are somehow some events that will trigger the execution or that will, somehow affect the execution of an application itself towards one path or towards another one. And malle malwares are usually embed usually contain a lot of bombs that are embedded within themselves, and that can affect the runtime execution.

So, other possible visual techniques are the ones that rely, for example, on detecting the environment where the application is executed, which means that nowadays, malware, for example, are able to determine whether they're running in a emulator or whether they are running in a rooted environment. And if that, of course, they can stop or eventually change their runtime behaviors that they can hide their, malicious, actions. So that is also, the reason for which it is better to run the applications in real devices instead of emulators. But there are several others, see techniques and signatures that can be also used by in order to change their behavior. For example, the lack of motion.

Emulators are not are never moved because they are not real devices, so it is possible to, determine whether or to discriminate between a real device and the emulators one. The malware are also able to determine or to see whether an application, is executing in instrumenting environment through exposed or freed up. If you execute an application in an emulator, there are some missing data, which very likely could generate the assumption that there is this is an emulated environment and not a real one. For example, there are no contacts, or there are no other applications running in the background. So there are a lot of techniques that malware nowadays can use for determining whether it is running in a real device by the user or not.

So just to summarize, the set of techniques that we've seen so far, this is the set of the overview. So, when we talk about static program analysis, we have, of course, the process that we can inspect the work code, so we can be sure that we were able to see the work code that is inside the application itself. But on the other side, we have, evasion problems, which could be, for example, defuscation, which could be the unavailability of some some code within the APK file because, for example, it is downloaded at run time and several, other issues that are generally called evasion technique and, are done in order to prevent the the analysis of malicious code. Talking about the dynamic program analysis, then we have, some, which is, of course, that whatever we see for the dynamic analysis is actually true, and we can be sure that, that will be is part of the logic of the application itself. On the other side, we have some limitations, among which, for sure, the code coverage because we are not sure that we will be able to execute all the parts.

And once again, we have some issues with the, evasion techniques as well. Now just to give you a flavor about, the most useful and used tool for performing static analysis, This is the interface of the Jadex tool. So Jadex, is a tool that they can pass the application, which means that it retrieves the source code of an application starting from the APK file. And it is pretty, simple and useful for, for inspecting application because you see here that you can, access to all the different resources and, different informations. But just to give you, an example, so this is a class that has been compiled, successfully because we can see the source code.

But there could be some other classes that, for example, are affected by obfuscation, and that is an example. So as you can see here, the names of the of the classes, have been randomized so that it is very hard to understand, to grab the other logic. So this is a pretty, common example of of excursion. Besides that, you can, anyway, try to, understand what is the internal logic and use this tool, which is, I would say, one of the most common ones for performance static analysis of an Android application.