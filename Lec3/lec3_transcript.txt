
So, welcome everyone to this new lecture of the mobile security course. Today, we're gonna see more in details how the binder cannon driver works in terms of, how it allows the single Android applications in, completing the action actions within their own sandbox and also, how the binder allows the application to the applications to interact between each other. And finally, we will see how the permit under permission what model works in terms of, how the permissions are defined within the Android operating system and how an Android application can actually request it. So wrapping up from the previous lecture, we have to, remind you important things and features that, are just part of the Android operating system. So Android is an extension of the Linux operating system, because if you never it's not a lot of features, but among some of them, some are pretty much unique, and you can find them only in Android.

One such unique features unique feature is the usage of the, user identifier. We have seen that in the Linux operating system, Linux is, the usage of the user identifier is pretty much associated to the physical user. So Linux has come as a multi multi user operating system, which means that for every user identifier, we have, an associated physical user while in android, since this is a mobile operating system and it means that it runs on personal devices, the original design adopted by Google assumed that there was no reason for, having a mapping between a user identifier and a physical user. So that's why in Android, we have that, each application comes with its own user identifier. We have, the Android sandbox model, which is the, core security element security guarantee that is provided by the Android operating system, and it guarantees both the, isolation of an application from the process, level and also from the file system level.

So this is the perspective from the, Android application. How does it work? So, basically, when you install an application, everything is done, of course, by the operating system. So at first, the, underwriting system assigns a user identifier to the new application that has been just installed. The number of the user identifier has also a specific meaning because, the system applications have user identifiers that, goes up from 1,000 and upper.

While if you have a third party app or a user installed app, usually, the user identifier comes with a number that is higher than, 10,000 10,000. So just by checking the user identifier that is associated to an application, it should be able to, check whether this is a system or a user installed app. Moreover, if you remember, we also discussed about the different partition where the system apps are installed, which is a slash system, and it is also different from the apps from the partition that is used for, the installation of the user installed apps, which our user are installed under the slash data partition. So as soon as the an application is installed, the Android operating system assigns to it a unique user identifier, and then it prepares the, private directory, which can be which is also called the, internal storage, and it is private to that application. And that's all.

So the, each application comes with its own private directory, and there is no way for the apps to, to access to access to, each other's private directory. So the apps, can save sensitive data in their own private directory, and they can be sure that there will be no access from anyone else on the same device. There is a specific usage about or a specific feature of the analytics system that comes with the user identifier, which is called the shared user ID. So So the shared user ID is a feature that allows 2 different apps to share the same user identifier, under specific request, which is, that they should have the same signature. So that means, that 2 different applications can have, can be assigned to the same user identifier only if they have been developed by the same people.

This is a reasonable assumption, of course, because if you have, 2 different apps that share the same user identifier, there are a lot of security implications in these choices. So it is better if the two apps have the same developers or if there is at least an agreement between the two apps. Sharing the same user identifier means that the application, basically, the 2 apps that you or multiple apps that share the same, user ID, basically share also, all the permissions that they declare. So if we have one application that comes with, for example, 10 permissions and the second application that has, the same user identifier, and comes with 0 permissions, since they share the same user ID, they are going to share also the same, permissions. And, of course, this is a problem, a vulnerability, which could be exploited by, malicious applications eventually.

And it is important that there is a check over the permission over the signature so that we can be sure that the permissions are shared by apps, that are sharing a common agreement or, yeah, an agreement between the developers. So this is a very unique feature. It is not really used used, and there are very few examples, but it can be used. And, you have to keep it in mind. So, as soon as the undergrads assigned user identifier and it prepares the private directory that is, the process that comes with the installation of the app, then the app is, executed, of course.

And at runtime, we also have additional security guarantees, which is that each application comes with its own sandbox, and it runs in its own in its own process. So, we have to think about the under the system as a set of as a combination of different sandboxes where each sandbox is assigned to each app single application, and this inbox is going to be executed in its own process. Given that, we can, of course, assume that there is a process installation. So the processes, as it comes also in the as it is also true in the Linux operating system are isolated from each other, so they can't really talk to each other unless we have seen we can rely on either process communication mechanisms. And, this is the isolation that we can kind of assume at runtime.

So we have an isolation or some security properties that are enforced during the installation procedure, which are the assignment of the user identifier and the private directory. And we have some security guarantees at the, run time, at run time, which come with the process isolation of the app that is executed in the in its own sandbox. Given that, if we think about, the set of possible actions or behaviors that an application can show at runtime, we might be wondering how is it possible that an application is, able to perform some actions if everything is, isolated and brought both at the process level and the the c in the file system level. And this set of actions can be, not only the interaction can not only refer to the interactions that, can occur between different applications, but also within the app itself. So for example, we should be wondering, how is it possible that an application can even show an activity if it is isolated?

How is that possible? Well, we kind of have 2 different level of security or isolation within the Android architecture. So let's go back to the picture that shows the under architecture with all the different layers, which, we have already mentioned in the presentation. And let's try to, somehow identify the security boundaries that are introduced in these, layers. So as you can see here, we have 2 different separations.

1 is kind of vertical, and it is applied to isolate each application from each other. So this is provided automatically by the Android operating system, and it comes with the Android sandbox model. So we have to, somehow imagine each sandbox as, we are seeing, like, a a vertical separation between one application and, the several other ones the several other ones that could be installed on the same device. But we also have an additional security boundary, which is, an horizontal one, and that effectively separates what is called the user space from the canon space. So, so far, we have been discussing about the Ambrosion box model, which is the separation between apps.

And we've seen and we said that, apps cannot interact between each other unless they rely on either process communication mechanism. And if you think about what is the main component that allows data process communication, which is the binder that works at the kernel level, we also have to discuss about this, separate this additional security boundary that comes between what is the user space and the current space. So the user space is, where basically the libraries and the applications label. So when you install an application, whether it is a system app or a user installed app, you have the app running in the user space. And the user space, of course, is, somehow the amount of memory or the amount of, space that is somehow allocated to the user and where the user can install application or do whatever he wants.

But, of course, since it is under the control, of the user, so the user can interact and can somehow modify this space, it it is it comes with some, restrictions or, limitations. So the user space by itself cannot do that much. You can see here that, the layers that belong to the user space somehow provide some let's say, provide a sort of certificate or a sort of signature for the applications for using the another printing system. But what is actually done at runtime? So the the the completion of a specific action of or behavior is actually performed at the canon level.

So at the chemist in the chemist space. Just an example, if you want, an application to show an activity, this action, so just showing an activity cannot be performed in the user space. It has to interact with the camera space. So with the underlying Linux kernel. So at the end of the day, we have these 2 boundaries, the inbox model that separates 2 apps, but also the, separation between the user space and the camera space.

And even though an application, doesn't interact with any other app on, installed on the same device, it tends to be, you see, this interaction between the user space and the camera space is always performed because an application by itself just running in a user space is not able to do anything. So let's try first to discuss how an application can, rely on this separation of the spaces and how the, let's say the interaction between the user space and the the kernel space is performed. And then we have so let's first to discuss how this vertical model works from the user space into the kernel space in the in the way backward, and we will, next discuss about how this, other separation between application works. So how you can allow the communication between 2 different applications. And, surprisingly, in both the situations, the component that is responsible for such communication or for such workflow is always the binder, which is, a kernel driver provided by the Linux kernel itself.

So let's start with an example. Let's pick up, let's pick up an application, which comes, which is installed. It doesn't have any special permission, or it doesn't have, any special request to interact with with other application. It just needs to, save a file on the hard drive. So by design, the applications runs in the user spaces, so they cannot do anything, which is, somehow which interacts with the underlying system underlying system.

And even just writing a file on the hard drive means that, the application should have access to the physical hard drive. And this is, of course, too dangerous, so it doesn't apply to, it doesn't provide the minimal security model. So even for writing a single file on the on the hard on the hard physical hard drive, the application needs to interact with the Nuance kernel. And as I said, the, component that is responsible for such interaction is always the binder. So first of all, what we have to do is, to understand the overall process.

So when we write an Android application, we basically, we can basically write it, we set in several programming languages. The most common one ones are Java or Kotlin, but we can also write the application in c or c plus plus. It doesn't really matter which programming language we are going to use. Then what, what matters is that, whatever logic you're going to write in your own application, this logic will be somehow, providing a higher level. So you're not going to write something that is executed at the canon level.

You're going to use the APIs that are provided by the system or better seen in, provided by general framework. So, if you write your code by relying on the Java API that come that come from the in that framework or the, native libraries, it doesn't really matter. What matters is that you're going to write some code that is, at a higher abstraction lay, level with respect to the kernel level. So in this example, for, which which concerns the writing, or saving a file on the physical hand program, we can use, for example, the following APIs, which involve the, output stream writer. So this is how, the way you might be you might be writing your own application, and you're basically relying on the other framework that is provided to user developer.

But under the hood, what happens is that this kind of logic or code will be, somehow translated into something that is expressed in a different language, which is, which can be executed by the kernel itself. So whatever action or logic you write, at the higher level, Java or c or c plus plus, it will be translated into a set of system calls. So, for example, if you're going to write, to save a file on the hard disk, you can use the output, 3 writer. But under the hood, this, API will be translated into a set of system calls. So, for example, you're going to use, in this case, the open open system call, the right system call, and the closed system call.

And this is applied to any kind of, behavior or action that an application needs to complete. So the first step is to, keep in mind that whatever code you are going to write, this will be translated into a sequence of system calls. And the sequence of the system calls is, the real language or the real, set of commands that the kernel can process and that can execute. So we need somehow a component that is responsible for this translation, and the component is the binder. So the binder is, able to, translate what is described at the higher level into a set of system calls.

When we refer to the system calls, we have to remind that, according to the different target architecture, we should agree or we should be compliant to different, convention. So so, just to give you some examples because it is, not really, relevant for purpose of the course, but it is a general, background knowledge that I think you should have. In Android, we can have, different architectures, basically, x 86 or ARM architectures. And according to the target one, you might have a different convention. Additionally, you, even within the sync architecture, you have to keep in mind that, whether you have a 32 bit architecture or a 64 bit architecture, the convention is likely different too.

So for example, if you have a x86 architecture, on, with a 32 32 bit version, the system call number will be, saved into this register, which is EX, and the arguments will be saved into this set of registers. To execute the instruction, you have to invoke this, system call, and the return value will be in a different register. If you use the same architecture but with the 64 bit, the same option, then the name of the registers will be different, and the same applies, for the, like, for the system call number, for the arguments, but also for the return value. If we switch to a different architecture like the arm, then the name of the registers would be, again, different. So, this is important when, like, you have to remember the different convention when you basically have to disassemble or, read the assembly code that comes from binary code.

So generally speaking, when you have to rely when you have to, inspect in an in another application, you will have something, what what you you will have what is called the sematicode that comes from the compilation of the Java code into this, valid code, which is an adaptation of the Java byte code. And that is human readable, but it comes with some specific conventions and, formats. But since, like, when you write an application using native code, the native code will be, compiled into a shared object file. And if you want to, for example, reverse engineer that shared object file, you're going to see some assembly instructions. And you have to keep in mind that the assembly instructions will be, different according to the target architecture that has been specified when the native code was compiled.

So just to sum up, this is a big knowledge that is useful if you're going to, reverse engineer a shared object, which comes from a native code, portion of the application that has been developed by introduced by the developers in the app itself. So, again, according to the different architecture, you have to follow a different convention. This is pretty much something that applies to any kind of binary. So it works for, of course, for the, Android operating system, but it also works for for Linux or for several other operating systems. So according to the different architecture, the assembly, the set of the assembly instructions, conventions, registers, and so forth are different, and you have to keep them in mind in order to understand what's going on.

So if you want to so to to to know more, you can just, query the man, manual, and you will have printed all the different information. So for example, here, you can see that on the left, we have the name of the target architecture. And on the right, we have all the different, registers that are used as the arguments. And, moving on, we have, for example, again, for each architecture, which is the name of the, of the instruction that allows you to perform, to execute a system call or, the register where the number of the system call is saved or, again, at the register where the return value, that is returned by the system after the location of the system call is going to be saved. So this is the big picture about how, they say, how logic that is provided at the higher level is going to be, translated into the lower level.

Fortunately, we do not have to, like, to do it manually because, as I said, we can rely on the binder. And the binder is, once again, a kernel driver, which is basically, responsible for intercepting any, invocation that is performed by an application towards the, Android framework. And it translates this API into a sequence of assistant calls. We can think about like, right now, the example that I've used is, a pretty standard one because saving a file on a physical hard drive can, be performed by any kind of, program. It doesn't really it doesn't really matter whether it is Linux or Android because this is a kind of operation that any program might be doing.

But, going back to the Android Android ecosystem, we have a set of different actions and, behaviors that the applications can do, which are mar far more difficult than just saving a file or writing on a file on your participant. So just to give you some examples, right now, you should have clear in mind that if you write, if you work in API, that is going to be translating the system into a sequence of system calls. But how does it does it actually work if you want to, or what what does it happen when you, try to access to the current location or you try to send an SMS or to try to see to show, to make your application show inactivity to the user. So this set of actions and behaviors are also part of the are, of course, part of the because we know that the applications have these kind of capabilities, but, they're kind of more complex than just opening a file and writing into the file. So, let's try to understand how does it work.

So within the application itself, we, we mentioned that everything runs, in the sandbox, but, more specifically, in the user space. And there are some set of actions. For example, let's use here the, as a reference example, the, access to the location that cannot be done, by the app itself if it doesn't go out from the sandbox. And, we know from the previous lecture that if sensitive informations sensitive information such as the location or, sensitive or important actions, such as, for example, showing an activity or, grabbing information about the other packages that are installed on the same device and so forth are provided by the system services. So the system services, once again, are part of the of the Android framework, and they provide, basically unique features that come with the Android OS.

And, what is interesting is that they are executed in previous processes. So when we run our own application, it runs in its own sandbox, but it also runs in a, underprivileged process because, of course, once again, we have to provide some security. We have to rely on some security mechanism. And the user space or, basically, the, user in solid apps can be can contain whatever logic the developers want. So, they can bypass the check, the type the checks that are provided and applied by the Google Play Store, or, we can even assume that the user has installed the application from a different source than the Google Play Store.

So there are several scenarios according to which we cannot assume that the, app or the the logic that is contained in an application that is run at the user space is secure. So what you can find in application in the user space is just, the logic for performing something, but then, the actual completion or execution of such action is controlled by the Android operating system. So in this case, we can assume that we have enough that tries to access to the location. The location is considered the sensitive operation, sensitive, sensitive data, and it is somehow contained and provided by a system service. In this case, we have the location manager.

Location the location manager. So first of all, location manager not only runs in a different process, so we have to rely on, a diff on a specific mechanism to to create, but it also runs in a privileged process, which is which means that with respect to the process where your application is running, the location manager comes with more privileges. And, among these privileges, we can encounter the access to the location information. So, at the end of the day, we know that the binder is the cannon driver responsible for such communication because it allows you to query a system service. But what is actually really interesting is that from the developer point of view, you do not really have any perception about how this, interaction between 2 different processes of core because everything is done under the hood by the binder, and it is, somehow hidden or invisible to the developer itself.

So just to wrap up, the binder is a cannon driver. It allows to perform remote procedure call and inter process communication. And it allows the basically to, it allows another application to basically leave. Because without the bundle, the an application, we, will not be able to do anything because as we we have just mentioned, even the simplest action that can be performed, such as writing a file on the, physical hard drive requires interaction with the kernel level. And such interaction is, handled by the binder.

So the binder is the component that is, that stands between the user space that allows to cross this bridge or to, communicate between the user space and the canon space. And, of course, this is a very critical component because when you jump from the user space, which is unprivileged into, the canon space, which is, a space, you have to keep in mind that are, like, you have to to provide some security guarantees. Some papers have been, some researchers in the previous years have been, investigating the internals of the binder, and they found that, there were some bugs and there were some, security issues. And, they actually Google actually fix them right now. But, you know, every time you have to cross or you you cross, you have to cross different spaces or you have, somehow an interface or something that works as a bridge, that is always a security critical point.

Because when you move from an previous, space into a previous one or the other way around, You can also you can always have some, security boundaries that are not checked or not or not, evaluated. And, of course, an attacker is going to, check those points as as as, like, the the very first attack vector for performing any attack. So going back to our, example, we were talking about an application that is going to access to the location manager service. So as I said, under the hood, we have to rely on the binder. And, this is a picture about how this, remote procedure call, is basically, allows an application that is running in a nonprivileged process to invoke assistant service that runs in a different process, which is also previous one.

So, first of all, the way this, interaction is allowed is, kind of implemented or performed by the AIDL language. So AIDL, just to remind, is, the language that allows you to have a client server communication. In this case, the client will be the, app our own application running in the user space and in in the nonprocess, and the server will be the previous process running again in the user space. When you write these, when you rely on the AIDL language to basically write, both the code for the, client and for the server, and the the language itself, automatically generates what is called the proxy, which is going to, to be saved into the client process and the Stubborn component, which is going to be saved into the server process. So in this case, we have the the the proxy is basically the following one.

So the location manager, while the stub is the location manager service. So how does it work? From your perspective as a developer, if you want to access to the location, you have to invoke the location manager. So you have to invoke the local proxy component that you have in your own, and previous process, and you invoke just the get last location API or whatever. As soon as you invoke this, local API, the binder intercepts the invocation, and, of course, it translates the invocation from the higher p higher p API into the, lower, sequence of system calls, and it forwards the request to the, previous process or more specifically to the stub component.

So, basically, from your perspective, you just see the location manager, which is locally, provided to your process. But under the hood, this invocation is, interpreted and handled by the binder driver, which is going to forward the same location towards the, previous process or better saying the, the server that in this case is the location manager service. As soon as the location manager service, receives such request, it returns to the for example, in this case, the value of the most recent location that has been registered on the system. And, once again, the reply with the return value is handled by the binders driver that goes back on the way, to the client component, and it was, the first sent to the the the request. Once again, you do not have to keep this in mind because you are going to because you're going to to to manually, rely on this model because everything is done for you already by the system.

But it's actually important to keep in mind that, when you invoke specific APIs, you are going to rely on a specific procedure that allows you to, interact with a different process or, even more important with a process that is more privileged. And this is kind of cool that everything is done for you, and you don't have to, like, to implement on your own. But it's better to know how the whole process runs and executes under the hood. So so this example, we we say that, like, we are proving that even for the execution for the simplest execution scenario of another application, the app the apps need to rely on the binder camera. Moving forward, so we said that without, accessing or interacting with the binder camera, the application cannot do anything.

And even more important in the underwriting system, we have a sort of, dependence from these, system services because they are extremely important, especially the activity manager and the package manager, because of the, all the set of, actions and behaviors that they allow the applications to do. So as I said, even if we assume, from scratch the simplest application that doesn't do anything besides, for example, showing a screen, we, when as soon as the application is executed at runtime, we are already relying on the binder kernel, driver, and we are relying on the on the underlying kernel, provided by the that is part of the another processing system. Let's switch examples. So in the previous one, we were just wondering how is it possible to access to sensitive data, which are handled by system service, and this is kind of, really specific sample. But if we assume that, for example, we just have an application that just wants to to show a screen to the user, so that is the simplest example.

Even in this case, we're going to, we're going to interact with the activity manager. Moving forward. So with the location manager, the workflow or the procedure that was, enabled by the binder is called the remote procedure call. While when you interact with a different application, the binder allows you to perform an interprocess communication, mechanism. We saw that, among all the possible ways that you can, perform an interprocess communication, we have intents, we have messengers, we have, AIDL, and we have somehow also content providers that are, that belong to this category.

Right now, here, we are going to see an example that, refers to, intents And what we want to to see or to to comment, to understand together is, how, the complete workflow actually works when you when you send an intent from your own application, which involves the execution of a component that belongs to another application. So let's assume that we have an application called a, and this application wants to start the activity x that belongs to the application b. So a and b are both user installed apps. They run-in different processes. They both run-in nonprevious processes.

But we also know that due to the sandbox model, the communication between these two applications can be performed only through, an inter process communication mechanism. In this case, an intent. So, application a sends an intent, and, we know that, in this case, we are going to send an explicit intent. So the intent specifically targets the component X belonging to the application beam. And as soon as the intent is crafted and it is also saved as an argument of the start activity method, the driver will be responsible for intercepting such API location and understanding what, what it needs.

So it is the responsibility of the binder of the of the binder to understand that in this case, we need the, activity manager system service. The activity manager is, once again, a system service that handles all the activities on another device. So, even even even when you, you start, inactivity of your own application, you have to rely on this activity manager service in order to perform, to show the to show the screen. So, actually, the, the first API location is sent to the bind to the binder driver, which for was the request to the activity manager. In this case, the activity manager understands that the intent is, directed, or it targets the component of a different application.

So it replies with the, set of information that is requested for the system in order to start a different, application itself. And this final information, it is forwarded by the security manager, is used by the driver, by the binder to start the new application and actually forward the, intent to this, to this app. So everything is done, as I said, in a very smooth way from the user and also the developer perspective. But, actually, when we execute this very simple action, which is just to send an intent from one application towards another one, we are, involving several other components, which are, some of which are in the user space, such as the activity manager, which, however, runs in our previous process, and some of which are in the current spaces, such as the, binder driver. And, this is actually how the, interface communication works, under the folder.

Now given this picture, we know that, we basically know how the app can, how an application can, live, can run by relying on the set of the APIs that provided by the framework. But, the next step would be so somehow, here we at this we've been discussing about the separation about, the separation between the user space and the kind of space and also between the different, sandboxes where the apps are executed. We also have, a set of additional actions or data that are provided by, the deliberating system. So right now, we have to think about how is it possible for an application to do more complex stuff or more sensitive stuff. So by design, so for the information that we have right now, we can basically have enough that can access to, assistant service or that can interact with another application through the inter process communication mechanism, and that is fine.

But there are certain, actions or information that are sensitive and, that need to be somehow protected through a security mechanism. And this come and here where it comes the, under permission model. So permissions are we already, as we already seen in the previous lecture, the permissions are, a sort of, way for the system to give access rights to the single, to the single application. And every permission is mapped towards a resource, which is a shared resource on the under the protecting system. So, for example, if we want an application that can access to the Internet or that can, get to the current location or, for example, access to the external storage, we need the associated permission.

So, permissions come in the following, way. So we have a set of permissions that are defined and that are part of the framework, which are standard, and, every application can request it according to the different, protection level. But we also have custom permissions. So somehow, from the developer perspective, we can rely on the permissions that are already provided by the system, but we we can also eventually declare our own ones. So let's start with the, permissions that are declared by the operating system itself.

So as I said, the reason for define the, say, security reason for defining, and the permissions is that we want applicate we want to enable applications, to access to sensitive data or to perform sensitive, operations, such as sending SMS or, connecting to the Internet. On the other way around, we can also think about this set of information or actions as a set of, protected and shared resources. So the needs to, map which application has the access, has the, right to access to such resources. And this is done through the permissions. Just to give you some examples, in this list, you can see some, examples of, permissions that are already provided by the natively provided by the system.

So we have the information, but also have the access to location, the SMS, and so forth. And, permissions, the permissions, the the the that are defined by the Android OS come with a protection level. We have 4 different protection levels, which are normal, dangerous, signature, and the signature system. And according to the, according to the protection level, the way the permission is granted to the app is different. Basically, the difference between the normal, the dangerous, and the signature or basically the difference between among all the 4 all the 4, different categories is that, the sensitivity of the data or, of the resource that the AMP is trying to access to is different.

So we can see somehow that the protection level is higher, going from the normal. So normal permissions protect the, least the sensitive data or the sources on the phone, going through all the different categories up to the signature or system 1, which protects the, most sensitive data or sources on the on the phone. So the normal permissions are basically the one that the ones that, are automatically granted when an application is installed. So you're not going to see such permissions, prompted at runtime. If you want to see such permissions, you have to go under the settings of the phone.

You have to click on the specific app, and you have even to, to go into an, an advanced set an advanced screen in order to see the full list of permissions. So normal permissions are basically, invisible to the user because they are they are automatically granted. And they, as I said, they, allow an application to access to the least sensitive, resource. On the other way, however, they are used by the in order to, map or to check whether a specific app has access rights towards a specific resource. One example of, normal permission is the Internet.

So when you if you want your application to access to the Internet connection, you declare the Internet permission, and this is automatically granted at the installation of the app itself. Moving on, we have the dangerous permissions. And, for example, permissions that consider dangerous are the ones at the location, the SMS, the access to the context, and so forth. The dangerous permissions nowadays are, involved or let's say, over the different versions of the system have always, implied an interaction with the user. So in order to grant a dangerous permission, the user should have had, granted the manually granted the, the right to the application.

But the, the way, the user, has to grant this permission has changed, and we're going to see it immediately afterwards. What is important is that permissions protect permissions protect more sensitive, sources, and that's why they request or they, they require an interaction with the user. Moving on, we have the signature permissions. And in this case, it means that, in order to be granted a signature permission, the application that requests that permission needs to have the same signature of the app of the app that has, declared that permission. So signature permissions are basically a way for 2 different apps to declare a custom permission and to share the same permission between each other.

So in that case, the permission is, let's say, available, in the operating system that is running on a specific phone where both the apps are installed, but only, specifically where the app that declares the permission is installed. But only applications that have the same signature of the declaring app can declare this information. So they are kind of customized the permissions, but also protected from a security point of view. Finally, the last, the last, category of permissions is the one that is called the signature or system. And in this case, we are referring to permission that can be granted to either system apps or, applications that, share the same signature as the declaring app.

Once again, system apps are the app, are the apps that, are installed under the system partition and that, they are usually signed with the, platform keys that are handled by the by the entity that is responsible with the responsible for the the specific Android image. So, let's see right now how the model for the permissions has changed over the different versions of Android. So the Android version, which involved the switch from the previous model, involving the dangerous permissions to the current one is Android 6. So from 106, and later on so even right now, we have the following model for the dangerous permissions. So the, dangerous permissions are requested at run time to the user, anytime the app is trying to access to the sensitive data or is requesting the permission.

So, for example, if an application is requesting, is trying to retrieve the location, then when does it there is an implication of that API, which involves a permission, the user is prompt with a message, and it has to, choose whether or not to, whether or not to grant such permission. And this is performed every time the app is, accessing or or is invoking an API which requests information. You can also have you you also have in the same dialogue a checkbox that says that you can, save, or, yeah, save the same choice forever. So it means that, eventually, the user can enable to that permission, or automatically enable the access to that permission every time the app, request it. But by design, what has been changed is that the every time an application requests an API that in in that involves a permission, there is a prompt for the user in order to conform confirm or to grant the the permission to the app itself.

So this is what you see. You have the one time dialogue that is prompted to you, and you can choose whether or not to, grant the permission to the to the application itself. You You can eventually choose or save the system to, remember your choice so that you do not have to specify it every time. On the other side, the the the security model that was, used for dangerous permissions before in web 6 was the following one. So at that time, all the permissions were requested at the same moment, which was the installation of the app itself.

And, basically, the the user doesn't have, didn't have any option besides, granting all the permissions at once because, what was shown to the user was something like that. So the user, the installation has, had only the the full list of the permissions, and, by the way, only the dangerous permissions, not even the normal ones. And, as you can see here, the only option for the user was to, accept, to grant all the permissions at once to the application itself. So pros and cons of the different security models. Considering the runtime model that is the one that we have right now, the process that the user can, nowadays install the application without, writing all the permissions at once, but it can have a more fine grained, choice or option because every time they have access to the sensitive API, then the user is prompt.

So somehow the user can, first of all, decide whether every time whether or not to grant the permission. But even, after granting the permission, the user has the option to to to revoke it. So you can, every time, change your change your mind and change your choice. On the other side, through the runtime permission model, the, the user can also have more context or information about why the application is requesting a specific, permission. And that is also important because somehow it can, affect the final choice or the final decision for the user itself.

One of the cons or the the advantages is that, it could be pretty annoying for the user. So what happens at the end of the day, very likely, is that the user is going to check the never ask me again option, and it basically see the prompt the very first time, and then it automatically grants the permission to the app, so that it is not going to to see more prompts, during the ongoing execution of the app itself. But this is up to the user itself. Let's say that the design model is somehow, it it introduces more security protection. On the other side of the previous model, considering the dangerous permission was definitely, of course, it was not annoying because the user was asked only during the installation of the app.

But on the other side, the user was not able to understand the context or or the reason for which an application could have access to a specific permission, and it didn't even have any option besides just accepting and getting all the permissions. So the permissions are organized in groups. So if you remember in the previous lecture, we, said that every application can have a single UID but multiple UAPs, a g group IDs, and each single group ID is mapped, towards the several permissions. So, just to give you an example, if we, think about the group ID of the SMS permission group, we can have receive SMS, read SMS, send SMS, or, concerning the phone permission group, we have the read phone's data, read phone numbers, and so forth. So, of course, detail this has some security implications because it means that, if your application, for example, requested the permission for reading or receiving the SMS, the group identifier that will be met and associated with, your application will be the same, as the.

So at the end of the day, with this design, what happens is that even if your application requests, permission for doing something, which means it requests specific permission, for example, reading the SMS, since the group identifier is the is the same for all the related, permissions, the same application could be could also, send an SMS because the group ID is the same. And this is, of course, security issue that nowadays still comes with the permission model. Finally, we can discuss about the, how the permissions can be embedded in application. So, the permissions are very important security information that an app needs to clear. And as many others, as many other information is declaring the manifest file, they are immutable, because the manifest file can be parsed is parsed at installation of an application, and it can be changed unless the application itself is updated too.

And, after the installation, what happens is that the Android OS parses on the permissions, and it retrieves the group that is associated with the specific permission, and it assigns the group identifier to that to the user identifier of the app. So if the app requests a different permission, then, we have the the UID of of that application will be mapped to the group ID, associated to the, in the, news group and so forth. Finally, as I already mentioned, we have a set of permissions that are declared and defined by the Android OS, but we can also define our own custom permission. First of all, let's see what's the reason what's the need for such permissions. Well, the main, application of such permissions is that of such custom permission is to protect the specific, components of an Android application.

So if you remember, I told you that, the applications can, the the the apps can interact between each other, and that they can also invoke components between each other. So it means that even for even retrieve thinking about the example about, that we saw before about the explicit intent from one application, we can invoke the component that belongs to a different one. Of course, if you declare so if you declare a component in the Android manifest file of an application, this is not, this cannot be invoked by other apps by default because you have to specify the exported attribute. So the exported attribute by default is false. So when you declare a component in the manifest file, it cannot be invoked by other apps.

You can set it to true, which means that you can ask that that you, allow other apps to invoke it. And what is is also, interesting to keep in mind is that if you declare an hidden filter for a component, it is automatically exported them. So let's say the scenario is the following one. We can have a set of components that, for example, we might want to export them because we might we might want other apps to access to such components, but, we wanted to know which, which app which apps are accessing such components. So somehow we want to make them accessible, but not by any application, just by specific ones.

And the way you can do it, you can achieve this is by relying on custom permissions. So with the custom permission, the idea is that, first of all, you declare the permission in the manifest file by specifying the name, but most important, the permission group and the protection level. And then you can protect the, the specific component with that permission. So it means that only an application that is declaring the same permission can invoke your component. So just to give you an example, here we have a broadcast receiver that is, the declaration intent filter.

So it means that another application can invoke such broadcast receiver by specifying this, action in its, implicit intent, but it is also protected by custom permission. So it means that the, application that sends the implicit intent needs to declare that specific permission. Otherwise, it will not it will not, be possible. The protection level of the custom permission is extremely important, and we have 2 different levels, signature or dangerous. If the, protection lever is signature, it means that the customer permission can be declared is declared by a specific app, and it can be used or, declared by other apps that share the same signature as the declaring application.

And this is basically a contract between, let's say, apps that are developed by the same developers. As an example, if Facebook if Facebook has different apps, such as Facebook, Instagram, WhatsApp, and so forth, it might have, a set of permissions that are custom so that only the 3 different apps can share specific data or specific components, and no other app is able to, to achieve the same goal because, of course, it will not have the same signature as the Facebook application. On the other side, we can also declare the protection level dangerous, which means that, basically, any app can declare a custom permission that has been declared previously by another application, but the user will be prompted as soon as the the application will be run. So this is, overall, a big picture about how the different security boundaries are introduced within the sandbox of an application when we have to think about the user space and the kernel space, but also when we have to think about the, interaction between 2 different sandboxes. And finally, when we have to think about an application that, needs to access to external resources.