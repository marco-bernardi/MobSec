
Welcome everyone to this new lecture of the mobile security course. Today, we're gonna see how is it possible to sign another application and to use such signature in order to distinguish among different developers. So first of all, the signatures come as certificates. So what when we are talking about a sign and an application, it means that within the Android app, we can find a certificate. Generally speaking, a certificate is an electronic document that contains some metadata that identify an entity.

Such entity could be, for example, a developer, but also a server, a company, or someone or something else. Certificates rely on public key cryptography, so that means that, the entity that needs to represent that is represented, or identified with the certificate generates a key pair of a public and a private keys. So the public key is the one that is embedded in the certificate, while the private key is the one that is, only, handled by the by by the entity itself. So that means that the private key cannot be shared with anyone else. On the other side, the public key is attached to the certificate itself.

The certificates usually contain a set of different information. So we can have a version, a serial number, a validity because usually the certificates come with a limited validity in time. The public key, which is as already mentioned, is used by the is, associated to a private key, which is not shared. The certificate owner information, which could be, for example, the, the name itself or the organization name or the location or some something else, The public expiration time, which is also important, and then the, certification authority that is, that has released the the certificate and also the certification authority to digital signature. So generally speaking, the certificates are sort of, letter of introduction that, as I said, the entities use for introducing themselves to the users.

So for example, if we think about a website that comes with a certificate, it it means that when you visit the website, your browser is going to, double check the certificate of the of the website itself, and it automatically receives the information of the developers or or of the server and identifies and checks if the server is a trusted one or not. There are different standards that can be used in order to create certificates. The most, common and famous one is, x 5 509. So, here is, let's see, very simple schema that allows you to identify how the complete workflow, that controls the usage of the certificate, usually, of course. So as a first step, as I said, we have a client that needs to, use a certificate in order to to, introduce his to introduce, him, himself or herself to someone else.

And, as a first step, it has to create a a key pair of a public and a private key. So here we have the generation of these key pair of a private and private key. And as soon as these, key pair is generated, the client is going to submit the public key, which is, which can be, of course, shared with, as I said, and with the world together with some metadata information, which allows to identify the client itself. The, so this set of information, so the metadata plus the public key is basically, what is contained in inside the certificate as a first step, and it is submitted to the certification to the certificate authority. So the certificate authority is, the trust identity that is responsible for the release of the certificate.

So, let's say that, the certificate authority is the entity responsible for double checking the entity of the client. And only if the entity the identity is, confirmed, the certificate can be issued. When the certificate is issued, as already mentioned, it contains the public key of the client, but also the metadata of the client together with some metadata of the certificate authority itself, such as the signature and the, the identification information. This way, certificate is a combination of information from the client and also from a certificate authority, and, it basically allows anyone to, identify or to verify the identity of the client or whenever this certificate is attached to, a sort of inform digital information. So let's try to, discuss about about a possible example about the usage the usage of the certificates.

So let's say that we have a bunch of data that we want to, transmit to somewhere else, and we want to, use this certificate or signature system in order to, from one point to to provide in order to guarantee different properties. We want to guarantee to our, destination, that the the data is, the the integrity of the data so that the data has not been compromised during the transmission. But we also want the, the destination, the receiver to be aware about, the identity of the sender. So we want to, allow we want to allow the the receiver to both double check the identity of data, but also the integrity of the data, but also to double check the, identity of the of the sender itself. So to achieve this purpose, we rely on our own certificate.

So as I said, we have a bunch of data, and, we first of all calculated the, the hash of such data through a hash function. So in this way, we basically we can basically transform a limited amount of data into a fixed, into an information that has a fixed length. And this information will be, no matter what is the input, the output will have always the same length. So this ash is a sort of, short, verification data that can be used to see if the original data has been compromised or not. So once we have calculated the ash, out of the data, we can encrypt such ash with our own private key.

So in the public key, in the public key cryptography, we have asymmetric encryption system where we usually encrypt with the private key and decrypt with the public key. So the private key is, handled by our own, by ourselves, and we can share it. So we can, encrypt the the hash with our own private key. And we instead share our public key attached with the certificate so that anyone else can, decrypt such signature. So this is the, basically the signature.

So this is the hash of the data that has been encrypted by, through our own private key. And this is the certificate. So the certificate is, just mentioned. It contains the our public key, the information about the certificate authority that has, released such certificate, and some metadata about, ourselves in order to, for the receiver to identify or to double check who we are. So once we have generated this signature and, we have, like, we we managed to to get the certificate from a certificate authority, we can attach both, so the certificate and the signature to the original data.

And we transmit this kind of information towards the receiver. As soon as the receiver, gets these, digital signature data, it can, as I said, identify or double check the both integrity and also the, trust the trust trustness of the of the sender. So concerning the integrity of the data, the, the receiver can basically, first of all, retrieve the original data from the, like, from the object that has been sent and calculate the hash through the hash function so that it can it can obtain the hash. On the other side, we have the signature. And thanks to the public key that is contained in the certificate, we can decrypt the signature by using the public key and get the hash.

So at this point, we can double check whether the data that has been sent has been compromised or not, Because if we manage to calculate the, AHS out of the original update transmitted data that is equal to the original ASH that has been signed by the by the sender, we can conclude that the data integrity is, guaranteed, is protected. So the the data has not been compromised. On the other side, since the certificate has been issued by a certificate authority, we can basically we can be sure that the, like, the the the center is a trusted, is a trusted entity. We have actually 2 different types of certificates. We have both public and also private certificates.

So the public ones are the trusted ones, while the private ones are the untrusted ones. So, how what is the main difference between these two entities or these two types of certificates? So when we go for a public certificate, it means that we have to ask the certificate authority to generate the, certificate for ourselves. The certificate authority, comes with a, hierarchy, which is, well known, and it is the following one. So we have basically a root certificate authority and then different subordinate certificate authority until we reach the one that we're going to query for the the generation of the certificate of our own certificate.

But, the wall, signature system works as follows. So, basically, the latest or, let's say, the, the certificate of activities in the lower part of these tree or hierarchy signs the, generates the certificate and provides the certificate authority digital signature. But this digital signature has been signed by 1 of the, by one of the upper certificate authority. In this case, the certificate authority 3, which, on his own has been signed by the certificate authority. So, basically, when, we're talking about the public system, the public certificates, and we, we need to get a certificate, we ask to certificate authority within this hierarchy, and the certificate that we get is trusted because there is this chain of certificate authorities up to the root one.

So you basically have response by this one, but this one has been, somehow double checked or, is guaranteed by this hierarchy of different certificate authorities. So this is not just a spare entity or company that says, I'm, like, the trusted entity that can reuse the certificates. There is a hierarchy, and, you can just rely on, such hierarchy in order to be in order to to get your own certificate. So, when it comes with public certificate, this is the ERT that you need to query, and the certificate that is generated is, signed by such, certificate authority, so it is trusted. On the other side, we have the private certificates, which are not trusted because they are basically self signed.

Self signed means that, you gen you can generate also, your own certificate, and you can, you do not ask to any certificate authority to sign it or to certify your, identity. In this case, with the private with the private certificates, what happens is that you can still identify you you can still have, metadata and information that, are somehow connected or related to the to the certificate owner. But you do not have any, like, external entity that has double checked the identity of the of the entity itself. And, in the Android ecosystem, what is actually, used is, the private certificate. So in the end of the ecosystem, we don't have, a certificate of authority, which is, created for the generation of the certificates.

But every developer can can, use self science certificate and embed it within its own application. More, let's say, more in detail, we have to think about what are the, let's say, the issues that come with this kind with this, choice. So in the case of, a website so in the web world, the style sign certificates are not, like banned. So you can see you can find some, websites that come with a self signed certificate. But the browser is going to warn you that the certificate that the the website might not be trusted because the the certificate is self signed.

So the so no certificate authority has, somehow double checked the identity of this, web website or server. So whenever you see a picture like this, a message, an alert like this, you know that you can still move forward within the navigation. So, like, nothing is banned or blocked, but this is up to you to decide whether or not to move on with the navigation. But the browser, which is the entity responsible for double checking or for, refining certificate of a website, is just informing or telling you that the certificate is self signed, so the, the website or the server is not trusted. In Android, we rely on the same system.

So as I said, we have private certificates. And the purpose is that the private certificates are used for not for, identifying the developers, but not just for distinguishing them. So the, there is a formal and really important difference between the usage of the certificates in the website board and the usage of those certificates in the, application or Android world. So in the website world, as I said, you can have both public and private. Usually, public certificates are the guaranteed trust of the website that you are going to navigate.

While if you have a self signed one, you can still navigate within the website, but it is up to you because nobody has certified or double checked the the identity of the developers or of the server. On the other side, in the ecosystem, nobody cares or, let's say, the purpose of the certificates is not to, like, to to to verify the identity, but it is just to distinguish between different app authors. So we already discussed about the unique information that identifies an application. This is the package name. But when we have 2 different since the package name is just a bunch of data that can be provided by any developer in the manifest file, a developer can any developer can basically declare an application that comes with a package name that is the same of an official app, for example, Facebook.

So how is it possible for us to distinguish between the 2 different developers? And so to be able to see like, the final scenario that we want to prevent is, to prevent that, for example, we have the official Facebook app installed on our own mobile device, and we also have, the Facebook app that has been developed, for example, by some attackers. And the Facebook the malicious Facebook comes with the same packaging as the original Facebook. What we want to prevent is that we basically update our our legitimate Facebook with the malicious one only because they have the same package name, which means also that when you update an application, basically, the new version of the app is installed within the same private directory. So if we update the legitimate, Facebook app with the malicious one, it means that malicious one is going to, to have access to the private directory of the legitimate application of the legitimate Facebook and so forth.

So it it basically has access to your sensitive and private data. So in order to distinguish between 2 different apps and be sure that they have been developed by the same set of people, we can rely on certificates, because, like, if we keep if we take the application the Facebook app by itself, nobody says can guarantee, can can can guarantee to us that the developers are really the Facebook developers. But what we can do if we have the, 2 different versions of the Facebook app is that we can double check if the signatures are or the certificates are the same. So if they are the same, we can be sure that they have been developed by the same set of people, bunch of people by or otherwise, they've been not. So, going back to the scenario that I was referring before, if we have the legitimate Facebook app installed and a malicious developer manages to public a malicious version of, Facebook on the place with the same package name, if we try to install it, we are not going we we we still is, we we are going to to to have an error by the Android operating system because the signatures or the certificates do not match.

And that means that the apps have been developed by different bunch of people. The same, you see the same information or the same check is performed to distinguish, for example, the system apps from the user installed apps or normal apps. So the system applications are the one that are installed, within under the system partition, but they are also the one that come with the system certificate. So it means that they've been signed with the same certificate as, the one used for the underlying platform. And, that is also how is it possible to, distinguish between the different applications and assign the system permissions only to the above mentioned ones.

So, once again, the usage is, of the certificate is completely different, and, we you you can also, you can also generate your set of private and public key and simply self sign your application. So right now, I'm I'm going to show you how does it work, or, basically, how you can generate a key, which can be used for signing your own application, then we we will double check what is the set of information contained into a certificate. So this is the command that can be used to, well, we can basically remove this program. Okay. So this is the command that can be used for generating this, key pair of fabric and private key.

And, the the certificate comes with a a password. So you this is the password that test me. That is the one that I specified. This is the hashing function, which is not the actually, the best one. That's why we are going we're also going to use, to get, like, a warning from the system, but this is just for, like, teaching purposes.

So if you're if you're going to generate a certificate and, you, like, you should be aware about which, ancient function you're going to use. So when you generate so this is the command that can be used in order to generate the, basically, the set of, key the set of keys used for the certificate together with the additional metadata that will be embedded in the certificate itself. So when you, when you launch this command, you are going to provide you have to provide a a password, and then you can have a set, you can specify a set of different information. So, for example, I can say that what is my name? Department, the university I am affiliated with.

The location. Okay. Italy. IT. Yes.

This is correct. And let's see. So this is the certificate. And with this command, we can, basically sign in another application. So this is the password, test me, that I specified before.

This is the APK file that I'm going to sign, and that's basically it. And this is the key and certificate that are generated before. So if you have this command, you're going to, sign, an APK file. And, what if you open the APK file with this program, which is called the JDX. JDX is a decompiler that allows you to, decompiler, basically to move from any file into the original source code of the applications somehow generated with some possible, approximation.

But concerning the signature, this is what we can see. So here, you can find the same information that I just specified also with the, typo. So my name, information about the organization, location, and so forth. This is the validity of the certificate itself, the type or the standard that has been used in order to generate the the certificate, the version of serial number, and the public key, which is the, information, the most important information used for decrypting whatever data has been encrypted by the the owner of the certificate itself and the signature type, which is, with DSA, which is not the strongest one as I, previously mentioned. So, right now, we should discuss about what is the main usage of the certificate itself.

So we can basically, as I said, we can use, first of all, the certificate in order to identify this better thing, in order to distinguish among different developers, but we can also use the public key, which is contained, the the key pair of private and public key contained in the certificate in order to guarantee the integrity of the app itself. So right now you see here that there is a warning because I haven't, protected with my signature all these files. But anything else, which is, basically the source code of the application, has been protected. So what does it mean? It means that I can within with the signature system, I can, calculate the the hash of a single file within the or offset of files within the other application, and then I can encrypt such, such, edge file with my private key.

And then I can share the application with, embedding the certificate and also these, encrypted edge values. So when I share my other application, the, is it it will be possible for the receiver to, distinguish between, for example, the developers of my app and another application in order to see if we are the same person or not. But it can also double check the integrity of the app Because if you can if you calculate the, the hash, of the different files within the application and you double check such hash with the, original value that has been encrypted with my private key, you can basically identify, whether the the application has been compromised or not. So just to sum up, in Android, we use the certificate to distinguish between we rely on a private certificate, which are, which, private certificates which are not trusted because we just rely on the certificates in order to distinguish among developers. And we can, on this side, however, guarantee the integrity of the application itself by generating this, set of hash values from the original files and encrypting them through our own private key.