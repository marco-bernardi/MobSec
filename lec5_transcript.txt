
Welcome everyone to this new lecture of the mobile security course. Today, we are gonna have an overview of the 4 different components that can, allow to build Android application. So as already mentioned several times, one unique feature that comes with the Android applications is that they do not have a single entry point, but they have multiple entry points, as many entry points as the exported components in the manifest file. The motivation for this design choice comes with the, usage of another application. If you think, for example, about desktop application, you usually launch and execute them, always in the same way.

So you basically interact with the icon that you have on the desktop, and then you launch the execution of the app. What happens on the Android ecosystem is that you can either, either interact with the Android application by clicking on the icon that you can find on the launcher. But, for example, other applications can also, trigger the execution of the app. And the entry point could be different according to the state of the application itself. So for example, you can have the application that is, that is launched the first first time.

And in that case, it will show the first activity, but you can also, put the application in the background and then retrieve it so that you can find the application in its, safe state, which could be a different screen. Or, if the application is triggered by another app, which is installed on the same device, you can have the app started, through a service, a receiver, or a content provider. So all the 4 different components that, that are activities, services, broadcast receivers, and content providers can basically identify possible entry point, of an application. By design, all the components are required to be, declared in the manifest file, with an exception that comes with the, that comes for the broadcast receivers. Because receivers can also be or are even, the developers are even encouraged to declare the broadcast receivers in a dynamic way within the logic of the application itself and not in the manifest file.

Besides that, we have to clarify or to remind you that it is not enough to, declare a component in the manifest file of the application in order to make it available to other apps, but, you have to export it. So, it is mandatory to declare all the different components in in the manifest file so that the Android operating system will parse the when parsing the manifest file of an Android application, will register all the possible components of the app and save, somehow, somewhere the different components. But, just declaring the the component in the manifest file doesn't make it exportable, and exportable means that the component can be called by a different application. So if you have a component declared in the manifest file, it means that only within, only that that component can be invoked only by components within the same application. If you declare in the manifest if you declare such component in the manifest file and you make it also exported, it means that even other applications installed on the same device can invoke that component.

So this is, very important distinction, and you have to keep this, always in mind because, of course, exporting a component that could, could eventually introduce or define a possible new attack surface because it means that the attacker can use that component in order to, execute or trigger, your application. So starting from the first type of components, we can discuss about the activities that comes, that come with, which are correspond basically to the graphical user interface that or to the screens that a user can see when it is interacting with the in another application. So among all the foresee all the four possible components, we can say that the activities are the ones that allow, the user interaction with Android application because they provide screens or, some graphical user components through which the user can interact with, the app itself. We usually have, we can have, we do not have any limits, any limit on the number of activities that an Android application can declare, but we usually have, by default, a single activity, which is the the default one, which will be invoked when you click on the icon, that is shown on the launcher on the device.

So this activity is usually the called main activity. And, besides the name, it is, uniquely recognizable by, the Internet filter that is associated to such activity in the manifest file. As a matter of fact, if you also, for example, create a default project, one of the default projects that that are available in Android Studio, especially one, of those that come with an activity, you will see that there will be one specific activity that, declares an intent filter that has a specific action and a specific category. So, this combination, basically refer to the to the intent to the event that is triggered whenever you click on the icon of the application. And this event is intercepted by the Android OS and then forwarded to the, to the application to the specific app in order to to start its execution.

So, when you click on an icon, you are, interacting with the Android OS, and it is responsibility of the Android OS to forward such interaction or somehow to elaborate such interaction in order to start the execution of the correct application. That is basically the one, which the icon you clicked on belongs with belongs to. As soon as an application starts, we have, we basically have that every single component has its own life cycle. The life cycle means that every component is specific to different states, and there could be, there are some events that trigger the execution or, the change of state between the, during the life cycle of the component itself. The one that is shown in this picture is the life cycle that comes with the activities.

And we see that, we can basically have we have several methods here or better sync callback, callbacks, which are, callback methods, which are which correspond to the transition between different states, during the activity like life cycle. So at the very first time that, when the activity and activity is launched, we have the execution or the invocation of the callback method on creator. This is, basically when the operating system creates the activity. So you should also remember that every time you invoke these, there is an invocation of this callback make method. The rendering is due to an interaction between the application itself and also the, underlying Android operating system.

So on create is the callback method used by Android in order to, create for the first time for the for the very first time your activity. And it is usually used by the developers for initializing all the different, essential components of the activity, for example, the, all the graphical, components. So the method that is, called the set content view, which is, which corresponds to which allows to define the layout of the activity is usually rendered, during the invocation of the during the execution of such, on create callback method. As soon as the on create callback method is, invocation is done, we can, move to the different state, which is provided with the to the different state, which is the started state, and that comes with the, on start callback method. So when the activity switches to the on start to the start state, it means that it becomes visible to the user.

Moving on, we, have the on resume callback method, which is, which corresponds to the situation or to the moment when the activity, just before the activity starts interacting with the user. So we have, that on start. When we have the activity in the started, state, we can already, see the screen. And, our resume, it means that we are going to interact with the screen itself. At this point, we have that the activity is properly running and is running in the foreground, so we can also interact with it.

And, we can we can also see the the activity itself. If we, for example, switch to a different application, the, then the foreground activity immediately goes into the post state, which means also the invocation of the on post callback method. This is, basically suited to, as I said, to a situation where the when the user, for example, can switch from one activity to another or from one application to a different other. So we have the foreground the original foreground activity here is put on post. So it means that it goes just, like, at the second place in the stack of the different activities.

So the when the activity, goes into the post state, the user is not, is not able anymore to see it because there is there will be something else in the foreground. And, but, however, the post state comes with, some particular features because the activity and activity that is in this post state can, for example, continue to update the UI even though this is not running in the foreground. So, even if it is in the background, it can still be updated. But, of course, there are some, this can be true only for some specific actions. So, they should be lightweight actions, as I mentioned, that just, small updates on the UI of the activity itself.

It is not recommended to implement any heavy activities or actions to be done when the, when an activity is in the pauses paused state. And when I refer to, heavy actions, I basically think about, for example, network, network activities, such as downloading data from the network or performing database transactions. So, an activity that is in the post it can still be updated. So when it comes back to in the foreground, the user might eventually see, see it modified, but it cannot and developer definitely shouldn't implement in the post state or in the on post callback method anything that is any action that is important, for example, transaction or, a network download activity. Moving from the, to the from the post state, we can, the the user, can eventually put the the activity into the into the stopped, state, which means that the activity is no longer visible at all to the to the user.

So, means that you just put the activity, Like, in the second layer of the text, you you can immediately retrieve. On stop means that you cannot see the activity anymore. So, we have, as before, the associated callback method. And, from these, stop the state, the activity can still go towards 2 different states. So it can go back to the from the stopped state back to the started or to the started state through the unrestart met callback method, which means that, basically, the state of the activity is restored from the time it was stopped, or it can eventually go to the, destroyed state, which means that the activity is completely destroyed with, all its resources, and everything is released.

So, if it was if there was, any process or action that was going on with the activity itself, this will be, not completed. So, overall, we can have the following, different states. So the start state, the running state, the post state, the stop one, and then we can have all the different transition from one state towards the other. When you work with activities, you have to keep, you have to definitely keep in mind this life cycle because, as I said, according to the, different callback method that you can use for implementing an action, you might see or not see such action implemented or executed at runtime. So you have to keep in mind, where, where is the exact point where you would like to put, or where you would like your activity to, to complete the specific action.

So this is, how the different activities can be, like, are executed in a time. So what's the life cycle of the activity itself? But we also see already that, of course, we have to somehow trigger the execution of the activity of the activities themselves. And when you, execute or trigger the execution, you can have 2 different options. You can start an activity just for the sake of it, or you can start an activity and then get back a result from its execution.

So there are 2 different ways for, 2 different APIs, that allows you to do to do so. The, however, the message, or the object that needs to be provided, whether you want to start an activity just for the sake of it or, for trimming a a result from it is always, any intent. So when we want to start to generally start an activity, we send an intent. We have to craft an intent, and we have to decide whether we want to go with, for an explicit or for an implicit intent. We specify in clear what is the target component that you want to, to invoke, which means that you have to specify the package name and the, component name, so the class name, of the target component.

If the component is, belongs to the to the application itself, you can even specify the dot class, which is the, basically, the bytecode associated to the Java source code of a specific class. And given that the, the application component is belongs to the similar to the same application of the component that is calling it, you have the, reference to towards the dot class file. If you're targeting, if your explicit intent intent targets, a component that belongs to a different application, then you have to be to declare or to refer to that component by strings. Otherwise, because of the of course, the dot class file is not available in your application. On the website, if we, want to specify just an action that needs to be completed, we use we can go for implicit intents.

Implicit intents means that we do not target a specific component, but we only target we only we just ask the Android OS to perform an action. Then it will be responsibility of the, of the Android OS itself to find the target component that is able to, to basically handle such such action. So, how is it possible? So if we want to start an activity, just for the sake of it, we can use the soft activity method. But if we want to start an activity and to get back our result, we have a different set of APIs.

So, let's say, recently, these APIs have been deprecated. So nowadays, you can still use them because, basically, under the hood, these, original APIs are still available in the web framework. But, if you are a developer, you should use the most up to date APIs. Anyway, the underlying concept is basically the same. So you, on the other from one side, we have we're soon to have an application a.

And on the other side, we're soon to have the application b. So what we want to do is to make the component x that belongs to the application a, invoking the, invoke the component y from belonging to the application b. So, we can do that by, as I said, by crafting properly crafting an intent, which could be, in this case, an explicit intent. And then we work the soft activity for result method, which, however, wants 2 different arguments, so, both the intent and also this request code. The the associated logic or, let's say, the, entry point for the component y belonging to the application b will be, of course, the on create method call where we see that, the it it will be possible for the, component y to, reply back to the, to the component that invoked it.

And this can be done by by specifically invoking the set result method, setting the result to k, flag, and then specifying the intent that we want to, provide back to the original, component. So, basically, from the, x, component belonging to application a, what we are going to see, is the following, is the implication of the following callback method. So the callback method is called the onactivity result, and it comes with, 3 different arguments, request code, result code, and the data. So the request code is the one we used in the invocation when we, when we invoked when we sent the request to the to start a specific component. Result code is the one that is, used back that is set back from the target component when it, class the replies.

The reply that is going to be forwarded from, application from, component y to the component x. And then the data, is basically the intent that is, once again prepared by the target component y, and that is sent back to the, target comp to the original component x. So from the from this component, it is the colon 1. We can if we want to start this component, y, and we want to retrieve a result, we basically invoke the stop activity for result method, and then we implement this callback method. So, what happens is that we send the intent.

The other device will, intercept the intent to find the, proper component able to intercept such intent. In this case, it will be, of course, the component y belonging to the application b. And, since this component will also, reply back with another intent, this will come on the callback method belonging to the, component x. So this, mechanism, which is back and forth, allows 2 different application to exchange basically 2 messages. We already discussed about the possible different mechanisms that can be used for, for 2 different applications to communicate between each other.

And, among different the different mechanisms, we just, re remind that we have, the the messengers, the intents, the, somehow, the content providers, and the the AIDL, mechanism. So the intents are not used for, allowing 2 different applications to communicate, to stop a real communication. The only, basically, the only, set of messages that you can use or the only possible communication is just to send a message and get a reply, such as in this case. So you can eventually send some data and and receive some data. But if you want to establish a long term communication between 2 different components, you can you should, rely on the messengers.

So, usually, intents are not designed, have not been designed for, allowing the, as I said, the communication. They just allow to trigger a specific component and eventually to get back some data from the component itself. So moving on, the second type of components that we have in Android are the services. And services are generally described as components that do not have a graphical user interface. So they are, just threads running and executing some, some actions.

And they can be, we can have 3 different types of services declared or defined in the Android ecosystem. So we have background services, foreground services, and bound services. So, the way you can, start so, basically, let's say that the set of features that come with services is very close to the activity because, let's say we have we still have to declare the services in the manifest file, and we can also, in this case, use intents to, for executing their, to to start that execution. The there is only one, strict rule which comes for, security one. So for the services, we have to rely on explicit intent.

And the reason is that when we we have, for example, in the activities, when we send an implicit intent, and we have multiple activities that are able to intercept such intents, such intent, we, the Android device would show, what is called, an app chooser to the to the user so that the user can select which app he wants to he or she wants to, to intercept such implicit intent because the activities come with interface. In the case of services, since we do not have a UI, event an implicit intent could be eventually intercepted by any service without, a feedback from the from the user or without any request shown to the user. So it is, better to invoke or even stricter to invoke to invoke, a a service by using by relying on explicit intents for security reasons. If we want and if we want a reply back from a service, this is slightly different than activities because we cannot rely we do not have a corresponding method, such as the for result. And we eventually, rely on the broadcast intents.

So you can start the service, and you eventually can back can get back a reply with an intent that is sending broadcast to the whole system. If you want to set up a different communication, we are going to see how is it possible, and that will be the case for, bound services. So let's talk about the first two types of services, which are, as I said, the background and the foreground. The main difference is that is the way they are running or the the way they are executed. So the background service is associated to an action that is not visible to the user, not not noticeable.

So it is called with the start service method, which, of course, comes, towards the invocation of the on create callback method and then on start command. For the back for the foreground services, instead, we are talking about an operation that is noticeable to the user. And in this case, we have the combination of the start service plus the start program method, which at the end of the day, go through the similar set of, callback methods. So the start service method inbox the on create callback method and then the on start command. So, the services are foreground and background services are pretty simple in in their design because, as I said, you can just invoke them, through the usage of intents.

You declare them in the manifest file, and you can eventually get back a reply through a broadcast intent. Moving on, the bound services are instead something that is likely, more complex, because bound services are more or less, let's say that they follow, more or less a client server a client server, design mechanism. So while for the foreground and the background service, we can just send an intent, and then the service is running on its own. So we do not have to take care about it, and, we not have to, also to handle its execution somehow. With the bound services, there is basically a connection between what is the calling component and what is the called component.

So the calling component is going to, rely on the bind service method. And, basically, the, application or the component that invokes the service to this method is going to be bound to that to that service. Being bound means that, the service will be running as soon as, as soon as there is a bounded component that is running. So, let me explain in a better in a clear way. For the foreground and for the background services, as soon as you send an intent, you don't have to take care about the service itself, which is also, which is also the same for the activities.

While for the bounder services, you are actually your your component is actually, somehow dependent from the, target service and the or the other way around. So the 2 components, so the calling, component and the bound service, the target bound service, are connected to each other, and they establish an interprocess communication mechanism to, to send messages between each other. And if your calling component is somehow, paused or destroyed them, the target bound bound service will be destroyed as well. So this is an important, let's say, design, choice, which also means that you, shouldn't implement, as a developer. You shouldn't implement anything that is, somehow that could be dependent that is, any action or, yeah, any action or behavior in the in a bound service, which could eventually depend from the existence of a different component.

Because if you do not have that component alive, your service will be, destroyed as well. How can you implement a bound service? Well, you have 3 different options. You can implement a local service. In that case, you will have just the interaction between 2 components belonging to the same application.

So, that is not, an issue, and we do not have to like, we still have to rely on the binder and so forth, but it's not an interprocess communication. It's just a communication between 2 components within the same app. On the contrary, if we want to have, if we want to target a different service, a service belong to different application, we can either rely on Messenger or on AIDL. Both them, as I said, especially the AIDL, rely on this, setup or on this definition of the client of a client server, communication mechanism. So, you can eventually also rely on, on intent.

But in that case, we're going back to the original model, to the first model of foreground or background services. So those are the main 3, different options that you can use. Basically, as I said, if you have to, implement something that you want to run independently, better to have it in a background or foreground service. If you want to have something that, continuously communicate with your, calling component, then you have to rely on a bound service. So, basically, what is, of course, the internal logic of the of the service itself is kind of custom.

What is different between these, three types of service is basically the life cycle. So the first two are independent. The third type is is that, it has a life cycle that depends from the calling component. And, yeah, as I said, if you want to make these 2, possible, let's say, the bond, the bond services, replying back to to you, you can rely on on messengers or or on AIDL. Okay.

So moving on, I just mentioned that, for example, for the services, we can use, if we start a foreground or a background service, we might eventually get back and apply through, a broadcast intent. So a broadcast intent is an intent that is is, again, an intent. But in this case, the difference is that it's sent in broadcast. So it means that it basically reaches all the applications that we have, on the, on the phone that are registered, that are registered for that specific intent. And the broadcast intents are specifically associated to broadcast receivers.

So broadcast receivers are the 3rd type of component that we have in Android. And as I said, they are the unique type of components that are, declared in a dynamic way. So let's say that, originally, they could have also been declared in the manifest file, through what is called the static registration of our broadcast receiver. So you, should have declared that the broadcast receiver in the manifest file with, its own intent filter. But nowadays, it is the documentation suggests to declare broadcast receiver only through the dynamic way, which basically means that you've not declared it in the manifest file, but you register, within the logic of your application through a few lines of code, such as, for example, this one.

So you adjust this, create an instance of your target class of receiver, and then you register that receiver for with a specific intent field that has specified the action that that broadcast receiver is able to to intercept. So, yeah. So nowadays, this is where you have to rely, you have to use for, declaring a the for declaring a broadcast receiver. The broadcast receiver is basically, let's say, a component that is designed only to intercept, this is designed 24 intercepting the events that are triggered in the system. So for example, there are system wide events.

For example, I don't know the level of the battery or, the installation of a new app or several others, that can be that are sent that are automatically sent and generated by the Android OS. And you can refine a broadcast receiver to intercept such events. Let's say that the purpose of the broadcast receiver is slightly different than, for example, a service or an activity, because the purpose of the activity is to show something to the user and to allow interaction, from the user with, the the screen of the phone. The serve the purpose of the service is to execute something, to keep executing something with which is which could be either independent or dependent from another component. But generally, its general purpose is to perform some action, long term action.

So, for example, if you have to download something, a file or anything else from the network, it is strongly recommended to do it in a, in a certain in a background service. The purpose of the broadcast receiver is is that only to intercept specific events that can be triggered in the Indian OS. And that's it. Then, of course, the, let's say, the internal logic that come that can come with the receiver is, of course, up to the developer itself. Finally, we have the content providers, which are the last but not least, component that we can have in the ecosystem.

So the last component, that is available on the ecosystem is, given by the content providers. Content providers are somehow defined or can be seen as a way for 2 different applications to communicate with each other even though, there is this is not a real way for, exception and communication. It's better saying a way for sharing the data between different applications. So the, design choice that comes with the content providers is that, as we already seen, all the other applications, when are installed on the, on Android device, are installed in a private are, associated, or, they have a private data directory such that the directory is, can be accessed by other applications. So it can only be accessed by the app itself.

And the app can save its own data there. The issue comes, with a situation that, where an application might need to eventually, say, share several data with other apps. So if we want to save to to to send just, a small amount of data, we can rely on intent, of course. But what if we wanted to share a full database or if we, if, the amount of data is significant? In this case, we can rely on content providers.

So, content providers are basically, an interface. So you can see here in the picture are an interface that, access to the real database, to the real data source that is, of course, handled by the application. And the, the content provider is the entity, is the component responsible for its access and to and for, giving back to the to the external world, which, in this case, will be a different application. An object is a content resolver through which the, application can interact with the, with this data source. So we basically have another source that is, of course, completely custom and designed by the application itself.

We have the content provider, which which is a component, the component we responsible for, handling or managing the access to such data source. And then we have the content of Solvay, which is the only object that is shared to the, outside world. The, content providers are, usually I are identified by a URI, which comes with a specific format. We will see an example immediately afterwards. And when you retrieve a content server, you can, you basically have a cursor object, which is which allows you to, to list all the data within the the content provider itself.

If you want to modify or delete, the data, you have to rely on the content resolver. So, in Android, we have 2 different types of content providers. We have the built in content providers, which are part of the other ecosystem, and then we have the custom content providers. So the built in content providers are the ones, for example, shown in here, and are the, the ones that you can already find in in any other system. So for example, you can see, you can, access to the content provider that comes with the browser the browser bookmarks or the all the details about the phone calls or all the details about the the contact contacts that you have on your phone and so forth.

So these are, built in content providers that are already provided on the analytics system. You can also, you can query them. So you if you eventually want to see their their their content, you can just, rely on the ADB shell content query, and then specify the URI of the of the content provider that you want to query. And, you can, in this case, you can see that the the whole content of the content provider itself. On the other side, you might want to to, define your custom content provider because, for example, you might have different, a different data source, and you want to, as I said, you want to share such data source with, external applications.

So you can either, modify let's say, you can either modify or interact with the built in content providers, or you can, define your own, one just, by extending the content provider class. So these are the 2, let's say, different options through which you can, interact with, or or you can define a content provider. And, of course, according to the different situation, you have to, find which which one is more appropriate. As I said, when, we want to retrieve a content provider, we, of course, have to to know the exactly which is the URI, which is associated to the content provider itself. As soon as we have the URI, we can, get back our content resolver, which allows us to add, to modify, or to eventually delete some data in the, underlying data source.

If we want to just to list the data, we can do that through the cursor. So, how you can, say, what is the format through which you can see the data? So let's say that the, custom underline of a source can be, implemented in any way the application or or the developers want. So we do not have access to that data source, and we do not have to take care about the, underlying data model because the, whatever whatever is the underlying data model, the content provider, and at the end, the content resolver will always expose the data in the format of a table where we have that each row corresponds to specific data with a unique identifier. And, of course, we have on the columns the, specific, different types of the data with their meaning.

So this is the the output. The input, as I said, is, URI, which always comes with a specific structure. So we have 4 different components or, eventually, 3 different components according to the, say, to the level of details of the data that we want to retrieve. So the first part of the, URI is basically, is always content, com, column// And this specifies, the type of data. So this specifies that we are talking about the content provider.

And this one is fixed and immutable and never changes. Then we have the specific name of the content provider, which, for example, in this case, is the content provider, the default one that comes, that is responsible for managing the contacts. So it is important to say that the content provider can have access to different tables. So, for example, in this case, we specify the contacts table that we can have the same content provider that is, that manages the access to several tables under, under its own control. So, the content provider is, this authority is basically the, entity responsible for, managing the access to the underlying data source.

But then we have to specify which type, specifically which table we want to get access to. And in this case, for example, we specify if we want to get access to the contacts table. And within the contacts table, we want the, specific, row that comes with the ID. As I said, this, the the mandatory part, of course, is the first and the second one because, otherwise, you will not be able to to retrieve anything. But you can eventually list all the possible, all the possible tables under the management of the same content provider.

And within a single table, you can, of course, list all the possible data that are associated to that table. So this is pretty dynamic, and it really depends from, the structure of your or the entity of your request. As I said, as, once you retrieve once you specify the URI that you want to get access to, then the content provider will, return a content resolver and, or eventually a. So the is the object that allows you just to read the data while the content resolver is the one that, allows you to modify the data or eventually add or delete them. So, overall, this is, let's say, a very high level picture of the different components, but this is enough to understand what's going on and, which kind of components do we need, we need eventually for performance of action.

Then, of course, the under specification is, Indiana documentation is required in order to understand deeply understand the different APIs associated to each component.