
Welcome, everyone, to this new lecture of the security mobile security course. Today, we're gonna introduce the classes of vulnerabilities that an attacker can rely on to perform, exploitations against the victim user. So the classes of vulnerabilities can be, several ones. And the list that we're going to provide here is definitely not exhaustive, but it is a bunch, of the most classic and the most well known vulnerabilities that had been encountered so far in the Android security ecosystem and context. And the the division or the criteria the criterion according to which these vulnerabilities will be presented is to rely on the effects of face.

So from the higher level to the lower level, the, possible attack surfaces that we are going to consider are the following ones. We would first start from the user, then we will, discuss about how is it possible it is possible to attack apps and more specifically third party apps and system apps. Moving on, we will discuss about possible classes of vulnerabilities that affect the system components in the Android operating system. And we finally concluded the lecture with some attacks against the hardware. So starting from the user, we will say that in this case, the most common most common set of possible attacks that can be performed against the user are classified as social engineering social engineering attacks.

Social engineering is a kind of technique, which is used by the attacker in order to steal, some information or to make the user, do some action. For example, we discussed several times about the malware that can be published on the Google Play Store and that eventually are, installed on the on the victim device. So in that case, the very final step of the attack, which means being able to lure the victim to install the, the malicious application, is called social engineering because the attacker, relies on a set of, features of the application, which should involve and should encourage the victim to install the malicious application. One possible example would be for to, publish an application that looks like is a very sim looks like a famous one or that, for example, gives some points or money to some rewards to the to the victim and so forth. So the the main feature of the social engineering approach is that the attacker identifies, what are so called the the weaknesses of human beings, and, she tries to exploit them in order to complete her own attack.

Another example is, the phishing attack. So phishing is a real classical example of social engineering because the the way the phishing attack is performed is to rely on the human beings' feelings in order to make the victim click on a specific link and eventually provide the the credential support, looking to a system or, sensitive generally speaking, sensitive data. So social engineering means identifying the weaknesses of the victim and trying to exploit them. Another possible example, which is not, related to the ecosystem, is the attack where is the physical attack, that controls physical access to a building. So let's assume that we have a building that is protected by some, checks performed at the entrance, maybe a badge or some password that needs to be provided by the by the people that enter the the building.

In that case, a social engineering attack is performed when, for example, the attacker manages to steal such information from the victim, some through some, let's say, some stories or some, information that confuses the victim. For example, the attacker can pretend to be, someone like a a technician or someone that needs to be to enter into the building, but he that doesn't have the credentials for doing that. And the victim might eventually, open the door or allow the access to the building itself. So social engineering is like a broader, a very widespread and broader, technique. So as as it always happens as it also happens for other techniques, Social engineering applies to any context and also to the, Android ecosystem more specifically.

Moving on and talking about the, possible attacks against applications. Here, we are going to list, several, let's say, the most well known and famous, scenarios. So, the 2 main features or the 2 main aspects that we have to, think about are what the attacker tries to do or what's the what the attacker would like to achieve and how he would like to achieve. So considering the, the purpose, the final goal of the attacker, the usually, the most common scenario scenarios are the following two ones. So the first concern, the abuse of sensitive, resources or permission, and the second one is the leakage of sensitive information.

Considering how, we can consider we should consider how the attacker can eventually interact with the target application and which are the possible entry points or attack surfaces. So according to the final goal so, the final aim of the attacker, of course, the possible attack surface could be different and could be even multiple, multiple ones. So let's give you some examples about how the attacker can set up an attack against the victim application. The as a very first scenario, we can consider an application that, for example, connects to a remote web server. So in this case, as you might have seen already, even from the challenges that that they release, If an application relies on the Internet connection to connect to a remote web server, there are several scenarios that we have to consider and which might eventually lead towards, attacks.

So first of all, let's consider if the network traffic is encrypted or in clear text. If it is encrypted, then the the attacker is not able to eavesdrop the the traffic itself or to perform a man in the middle. If the attack if the network traffic is, for example, a clear text, then the attacker would be able to, of course, to, to read the the whole traffic towards their own server and also then try to modify it, at runtime. So the majority of the attacks that concern the network connection can be classified as many in the middle attacks, which means that the attacker is between the the application that runs on their mobile device and the remote web server and the remote server. And the attacker intercepts such traffic in order to either either just read the content of the traffic or eventually modify it at run time.

If the attacker, wants to perform this kind of attack, it has to be a proximate attacker because it needs to be, in the same local network as the as the victim. So you cannot do it remotely. And you also, let's say, do not really need it to be a local attacker, because a local attacker means the attacker has to install an application on the victim device. And, that is, let's say, a less common scenario. It might also happen that the attacker can sniff the, network traffic by installing an application.

But that worked on previous versions of the system. So nowadays, if you want to perform, a, you have basically to intercept the traffic coming out from the mobile device of the victim and going towards the, the remote server. Another possible, feature that can be exploited for performing an attack against an application is the dynamic code loading. So far, we've been introduced we have introduced this technique as a malicious, technique used by Malvares in order to, to prevent it, to bypass the static analysis and eventually even dynamic ones because it is usually, the user it is usually exploited. Then I'm recording it.

It is is usually exploited to, dynamically load additional code eventually, the malicious one, after a certain amount of time, from the start of the execution of the application itself. But besides that, the dynamic can also be a technique that is used by legitimate applications. So this is actually the real, purpose with which the this technique was first introduced by Google in the ecosystem. So at some point, Google introduced a limitation in the dimension of the apps. So in the dex file, there were only there was an upper limit in there was an upper limit of possible methods that could be embedded in a dex file.

And that means that, some applications, especially the ones that used to be really big, were not allowed to be published on the Google Play Store anymore. As a possible workaround, Google introduced also this technique, which allowed this kind of application to split their own logic in several, several binary files, several several dex files so that the the dimension of the app published on the Play Store was reduced and was within the limits and the amount and the limits per the limit, defined by Google. But, after the the installation of the of the app, this one could download additional code and, execute it at runtime. So in a scenario where the dynamic coding is used by a g meter application, an attacker can perform, can exploit this technique in order to attack the victim application. And, the possible way to exploit it is to basically modify the code that is going to be dynamically loaded by the app itself.

So when there is an application that legitimately uses the dynamic code logging technique, it is always important to check, first of all, whether this, additional code is downloaded through an encrypted or an traffic that is in clear text. Because if the attack if the traffic is in clear text, the the attacker can already identify the binary file from where it is downloaded and eventually modify it. The second step is to or the second check is to is to, verify, which is the final location where the binary file is saved into the device. So, for example, if the additional dex file is shipping to a shared location, which will be the SD card or several others, the attacker can access to the same file and eventually modify it with, another one that is malicious. So dynamic code loading against the day, nowadays is more, more often used by malicious applications, but it can also use by legitimate ones.

And in that case, it could be a possible attack surface for the attackers. Another possible, example concerns the cryptographic vulnerabilities, which usually come, with the cryptographic APIs that are provided by the framework. So the idea in this case is that the, the, the developer of the app usually, let's say, have a are prone to introduce some vulnerabilities, with respect to their cryptographic functions, due to two possible reasons, either because they misuse the APIs that are part of the framework or because, they the maybe the the the APIs themselves cannot be are not well designed if they, for example, come from external libraries and so forth. So at the end of the day, if the application relies on a weak cryptographic library or implementation, it means that, in that case, the cryptography can be broken. So eventually, a file that has been encrypted can be decrypted and so forth.

So the cryptography is not reliable is not reliable anymore. Moving on, we can discuss about another interesting interesting attack that concerns, that refers to mobile application, which is called the Confusing Deputy problem. So in generally speaking, the Confusing Deputy attack is a sort of higher type of higher family of attacks. So there are a bunch of attacks that belong to this category that we're going to introduce immediately afterwards. Generally speaking, when we talk about the confuse the deploy attack, it means that, there is a malicious application that it tries to exploit exploit the features of a legitimate app to access to sensitive, sensitive data or to perform sensitive, actions.

So standard scenario is that we have an application a that has access to sensitive information, and it has a functionality that relies on the usage of permissions. And the attack is implemented by another application, application b, that, relies on the features from the application a that are not properly protected to, to either accessing these sensitive information or performing these sensitive functionalities. So just to give you a clear explanation of the pack, let's say we have application a that is legitimately, allowed to accept to access to sensitive information or to perform some sensitive actions. And we have, this application a that is not properly protect protecting such features and sensitive data, which means that it allows in several ways. So it has several attack surfaces that allow another application, application b in this case, to, to access the sensitive data or to the sensitive action.

So application b relies on the on these attack surfaces that are inadvertently exposed by application a to, to access to sensitive information or to perform sensitive actions. One possible attack that is a subset or a subcategory of, of, the confusion deputy problem is called the component hijacking. So in the component hijacking, the focus is on the exported components from the by the application A. So in this case, application A, has some, components that have been inadvertently left exported, and that eventually, can lead towards the sensitive information or towards the sensitive actions that I mentioned before. Another possible example concerns the permissions.

So the permission leak means that, we have an application again, we have the application a that requires some permission and some permissions, and we have application b that can use the permission of application a somehow. So in this case, application b does not have to declare the same permissions as the application a, but it uses the application a in order to, for example, to complete some action that require that requires that permission. So if you check the manifest file of application b, it will not contain such permissions. But the logic of application b relies on the exported on the attack surface by exposed by application a to, to complete this action and exploited a set of permissions. Another possible scenario, again, which is a subset of the, of the confusion data problem, concerns the, contact providers.

We know that contact providers are, specifically a specific way for applications to share data with other apps, but sometimes they are properly they are not properly designed, which means that they can eventually lead to access to sensitive data or even to manipulate the sensitive data, the sensitive data and pollute the database itself. Moving on over permissioning is, an instance. So in this case, the situation is that we have, again, application a that this time comes with a set of permissions among which some are not even used. And that, this scenario is generally called as over permissioning, which means that there is we have an application that, that is requesting more permissions than the, than the real one the real, needed ones. And, of course, we have on the other side another application, again, application b that exploits such permission in order to, to perform some sensitive operations.

So, by design or by itself, the over permissioning is not a real vulnerability, but it is a it can lead to it can open an additional attack surface and eventually lead to malicious actions. Again, the set as I said, at the start of the lecture, the set or the classes of that we're going to introduce here is not exhaustive, but it's somehow a collection of the most well known ones. In this case, the zip path traversal is not a very common one, but it is quite interesting. And, also especially because, it has been really it has been it has been really implemented by, so there is a sort of real use case scenario where this attack has been, considered and exploited. So let's first consider what is the vulnerability that is used.

So the problem is that when you have a zip file, you might have some files that have a path that that refers to a different location. So for example, zip file can contain a relative path such as dot././ in the name of the file, which means that as soon as the zip file is unzipped, this file will be, saved and copied into a different location, which is eventually the one that is exposed here. And if this location, for example, already contains some, files and data, with the same name of the of the of the file that is in the zip file, the at the end of the day, the original files are going to be overwritten by the the new one. So the vulnerability is containing the zip file, which should be properly checked and sanitized before being unzipped. Because as soon as you unzip the file, if you have some files in this zip file that have, for example, a relative path, you might override some existing files on the on the mobile device.

So, as as I mentioned before, what is interesting about this attack is that, there was, in the past, a real text scenario that takes part of this vulnerability, and this attack was performed against the Samsung keyboards. So, just to give you some, say, more details. So the the update of the Samsung keyboard was basically a zip file downloaded by downloaded through an HTTP request in clear. So not even encrypted 1. And 1 did once the zip file was downloaded in the in on the mobile device of the user, it was supposed to be unzipped.

It's important to consider that this zip file comes with the files that have the system permission. And, what happens is that during the, the download of this of this zip zip file, since it was, shared and downloaded by an unencrypted traffic, the attacker managed to, modify it at one time with, a malicious zip file, and that malicious zip file contained or exploited the zip traversal zip path traversal vulnerability by containing a file with a path like this, which event which eventually, after unzipping the file, ended up with the overriding of the following files under the, with the system permission and, under the sensitive, sensitive directory. So, basically, the, code that concerned the Samsung key the concern that the setup, the Samsung Samsung keyboard was overwritten by malicious files, and there was, basically no way to remove it because, they were installed, with the system permissions. So the attack was extremely simple because for the attacker, it the attacker didn't have to do nothing besides replacing a file that was downloaded through an HTTP request. And, once the zip file was installed was downloaded and unzipped, the attack was already, basically, was was already completed.

So how is it possible to defend against this type of attack? Well, as I said, it is important to sanitize and check the content of the zip file itself. So whenever it occurs that you find a relative path within a zip file, you have immediately to, let's say, prevent and stop the unzipping of of the file itself because otherwise, the attack will be already completed immediately after the unzipping. So other possible scenarios or, a pack of faces against the apps could be the native code. So what is interesting about native code is that, since native code refers to both the c and c plus plus programming languages, we are basically writing code in C and C plus plus instead of another application.

So all the possible vulnerabilities that already come and that already affect these programming languages will also apply in the ecosystem. Some examples are the classic, vulnerabilities that come with the with this kind of native code. So for example, buffer overflows, stack overflows, and so on. User apps at the let's say all the vulnerabilities that and exploit that can be used against the memory that is not properly released after its usage and so on. So all the attacks that we, that are already well known by the community in the native context are basically saved.

And, I mean, not saved, but can be used in, in an ecosystem. So not only we have the vulnerabilities that come with the Android framework and the ecosystem, but we also have, inherited the the ones that come from a different programming languages languages. So the the issue is that we do not have to, like to consider the native code as a secondary secondary location of vulnerabilities because the set of vulnerabilities can be, really high also in this, in this case. And it is not that hard for an attacker to trigger the execution of these vulnerabilities. So for example, if you have a buffer overflow in a c class in a c sorry.

Not in a c class, but in a c file within the in the c logic within the application, it wouldn't be that hard for the for the attacker to reach that point. So when we check for possible attacks with faces, it is always important to remember to check both the traditional surfaces that come with the an application so the manifest file, the exported components, the permissions, and so forth, the Java logic, but also the native one. So generally speaking, the majority of vulnerabilities are somehow related to, to an API, So the unfortunately, the the developers, sometimes are not aware of the proper way for working or using an API. That means that, as for example, for the case of the cryptographic vulnerabilities, if, the developers themselves do not properly invoke the cryptographic, APIs that are provided by the alert framework, they are themselves introducing vulnerability in a text interface. So, the majority of the issues that can come with, other applications is that, is somehow related to the capabilities of the developers.

So if developers are not, let's say, do not have the proper knowledge and the proper background, security background, they might introduce several vulnerabilities on their own. So moving on, another possible attack surface or set of, let's say, components, that can be attacked is the under the system or generally speaking, the other architecture with all the different components. So if you remember, the, Android architecture relies or has several components such as the kernel, such as the the system applications, the libraries, both the native and the Java ones, the hardware sectional data and so forth. And, when we when we speak about a packing the system, it means it means that, we are going to consider the vulnerabilities that part of the architecture. So when you have an a vulnerability within an application, it means that that vulnerability is part of the logic of the application.

When we talk about vulnerabilities of the system, it means that the architecture of the Android ecosystem itself is somehow backed. And in this case, there is nothing better than considering the Android Balatins. So Android Balatins are, this monthly, monthly announcement provided by Google with all the set of CDs that have been found and that have been patched by Google itself and that concerns the different layers of the architecture. There are, of course, several components, in the as I already mentioned. So even when you check the vulnerabilities, you will see that for every vulnerability, this has been categorized with respect to the component of the Android architecture that it refers to.

So we have several that refer to the framework, to the media framework, to the kernel, to the system, to the hardware components, and so forth. One possible, attack that has been implemented in this that's been implemented is called, let's say, is called the self unsafe self update. And in this case, what the attacker exploited was, the update of the Android image itself. So, basically, they, managed to release some applications that were requiring permissions that were not yet available in that version of Android but in later versions. So for example, let's suppose that we have, that the attacker knows that a target device is running Android 11.

And let's assume that in Android 12, the, Android ecosystem has introduced a new permission. So what happens if, you install an application on Android 11 that requires the permission that has been introduced only in Android 12? Well, the researchers that have been, addressing this attack will basically define this possible vulnerability because, what I what what happened at the end of the day was that as soon as the, the Android version on the mobile device was updated from Android 11 to Android 12, the the additional permission was automatically granted to the application. So basically, the, let's say, if we have to classify somehow this attack, we can speak about privilege escalation because the application that was first installed on with an additional permission that was not yet provided was automatically granted that permission as soon as the, Android Android 30 system was updated without any, without any, let's say, acknowledgment with respect to the user itself. Of course, when we talk about the vulnerabilities, when we refer to the vulnerabilities that affect the Android architecture, the severity of the vulnerabilities can be really different according to which component is targeted.

So if we are talking about vulnerability that affects the kernel, it is very likely that this will be with a high severity, in terms of impact, even though on the other side, it might not be exploited so, so often. So talking about was really, really exploited exploited very let's say, in a very easy way. The media framework was, the most buggered, and the most vulnerable component, in the especially in the previous versions of the operating system, especially in the previous version because at in its original design, the media framework was responsible for handling all all the media within, coming into the mobile device. So the purpose of the media framework is to process media context. So it means images.

It means, videos and so forth. And what happened is that, basically, a vulnerability was found that could allow, to, the allow the attacker to remotely execute some code just by relying on the media framework. That code was embedded in the media. In that case, it was an image. And by relying on the media framework processing of the image, the attacker were able to execute the to make that the code embedded in the image itself executed.

So basically, the attack surface in this case was the image, or basically the attack vector. In that case, it was the image. The image was carrying carrying some malicious code with itself. And that code was supposed to be executed by as soon as the media framework was parsing and processing the image itself. After this, vulnerability, the Google decided to rearrange and redesign the media framework in order to be able to, support to to to split by splitting the media framework in several components, one responsible for the processing of a single component or a single media, object.

So nowadays, we have the media framework that is created in several parts, one for processing the images, one for processing the videos, and so forth. So let's say the vulnerability has not been really fixed, but at least, say, the impact is limited because if you manage to, even if you manage to break one of these subcomponents, the, vulnerability is somehow bounded and limited within that specific component, and it cannot reach other external ones. This, attack that I just mentioned was real one, performed in 20, 2015. It was called stage fright. And, as I said, it was, basically, relying on the exchange of an MMS and, allowing the remote code execution from an attacker just by sending an MMS because it relied on the processing performed by the media framework.

This vulnerability is extremely important because this was the starting point or the trigger event that made Google start publishing the Android the monthly Android Wallet teaser. So from that point till nowadays, Google started releasing every month this announcement with all the set of CVs, which means vulnerabilities that are very precious and all the associated information. So that this, why this, let's say this attack is extremely important. Just to give you some details about the attack, basically, the the bug and the vulnerability that was exploited was nothing more than a buffer overflow. So, the context, again, is just by sending an MMS, the, the attacker was able to include that, by exploiting a buffer overflow a buffer overflow, to include in the to include some additional issues code that was eventually executed by the media framework processing.

So the attack vulnerability in this case is, basically here, where we have the mem copy function from a buffer into the sorry, from the data that are copied into buffer and, with a certain size that is considered, with respect to which amount of data should be copied in the buffer. Now if we check, the size of these three components, we see that the size is first, with 0, but then it is equal to the amount of data. While the buffer is supposed to be a certain amount, which is given by size plus an additional amount. Now the point is that size is declared as of type size t, while chunk size is declared as UINT 64, the issue is that the behavior and eventually the final dimension of this buffer will be different according to whether we are on a 32 bit architecture or on a 64 bit 1. So on a 32 bit architecture, this, amount of this amount this dimension of the buffer will be truncated.

While on the 64 bit architecture, this will be, this might may overflow. So at the end of the day, it could occur in a situation where we have the size of the buffer that is, this is less than the size of the data that are copied, which means that all the additional data that are, in any case, copied on the on that specific memory region will, will see the copy. But after the location of the buffer, eventually leading towards a standard and traditional buffer overflow attack. So the buffer attack is exploited, is performed here. And basically, the idea is that we copy all the day all the data in the buffer as soon as the buffer by bridging the end of the buffer.

And then all the extra data are still copied in the memory location, which will be eventually, executed by the media framework. Another possible, example of vulnerability that targets the system are the ones provided against the baseband. So in this, again, we can mention these real attack that was performed against some devices that just by connecting to a base station, they were actually compromised. Because the attacker was able to achieve an execution scenario. So just by connecting to a base station, the attacker was able to, run some code on the malicious on the devices that were connecting to that base station.

So, eventually, moving from a remote attacker, because, in this case, the attacker is not even in a physical proximity location with respect to the victim towards an approximate attacker. So from a remote, it can be considered more or less a proximal attack because it can achieve the remote code execution of some code in the, in the device. Moving on. The is another location or another component, that can have several vulnerabilities. And this is also extremely sensitive and extremely critical because we could the is involved, of course, at the, during the startup phase of the of the device itself.

So, what what could happen if you compromise the bootloader is that the at the end of the day, the device might load some malicious code that will compromise the the world's rating system. So with respect to the previous vulnerabilities that we have considered, for ex especially, the ones that concern an application, in that case, the we can somehow be safe because at the end of the day, the location of the vulnerabilities is, embedded and sandboxed within the application itself. In this case, if we compromise the bootloader, it means that we're going to compromise the whole device. So it is extremely, extremely significant and impactful. We might end up with, for example, a permanent denial of service.

Or we can just break the what is called the chain of trust, which means that the image of the system is not checked anymore. And you can eventually compromise it on the on the victim device. Finally, we're going to mention a very interesting attack that concerns the DRAM cells, which is called the raw handler. And that is very popular and extremely effective in terms of, the possible outcomes that it can reach. So let's say that the scenario is more or less like this.

So we have some cells, physical cells, in the memory. Or to say we can have we can assume to have this representation of the memory as a bunch of cells, one close to each other. And the situation is that when we access to a specific location in the memory, we are basically stimulating the cells, that are located in that portion of the memory. So the idea of the attack is that if you properly stimulate these, if you properly and, if you properly stimulated these lines, these cells multiple times, you might eventually lead towards a bit flipping in adjacent cells. So that means, that the attack is performed as follows.

So let's say that we have here a cell, a portion of the memory where, for example, that could be a volume value that allows, that allows you to access to a certain portion of the memory or that, for example, allows a privilege escalation or so forth. So we know that at this in this location of the memory, we have some sensitive data that we want to change. And since we do not have access to this location of the memory, but we have only access to other cells, we're going to, to access to the other cells so many times, in a repeated way so that at the end, we will we are going to stimulate a bit in the, in the cells that are inviolate. So the overall idea of this kind of attack is that, it relies on, let's say, on the electronic components that are part of the memory of the device. And the idea is that when you stimulate, when you get access to a certain region of the memory, you're going to stimulate that region of the memory, and this stimulation might eventually lead towards the leakage of, of some electrons in the nearby.

So these multiple and, stimulations of the adjacent cells can lead towards a bit flipping in, for example, one cell in this memory region. What could be the possible scenarios for relying on this attack? Which seems to be crazy, but at the end of the day, in terms of implementation, it just requires you to get access to a certain memory region multiple times in a very with a very high frequency. So if that occurs, you might eventually change, for example, a Boolean value somewhere else. So, when you change the Boolean value, it means that you're going to cause a bit flip.

So 1 bit in, the memory could be, at first equal to 0 and changing to 1 and the other way around. So as I said, you could you could rely on this type of attack to perform, for example, an escalation of privilege or to disable or to enable the access to some, some other sensitive, regions of the memory itself. So the most standard way for exploiting this kind of attack is usually to rely, on the, as I said, on a page table entry in a vulnerable location and just try to get access to that location in order to bit flip the, specific memory region that we are trying to target. So, this has been exploited in many with many different, aims. For example, escaping the client sandbox.

So the sandbox somehow can be, let's say, turned off by, just a bit flipping, by escaping JavaScript browser sandbox or crossed with some machine exploitation. So these are just examples that with the that by relying on the changing of a single bit in a certain memory region, it eventually can, modify the set of privileges the application has and, lead it towards a new set of attacks. Just a final note about the possible bugs and vulnerabilities that we can find. Let's say that we already discussed about the different severities and vulnerabilities which is not always the same. We know that the severity is given by the type and by the location of the vulnerability itself.

But in terms of fixing, also, it is important to consider the severity of the vulnerability itself because fixing vulnerability is not always easy. So I say that if the vulnerability is a standard one, which means just a specific, for example, misuse of an API or something that can be, or, for example, just check a boolean that is left there and it can be immediately changed. Changed, then the the uptake and the fixing is very immediate. But on the other side, if the dump concerns, like, an improper design, then in that case, the fixing could be really demanding and, significant. So according to this scenario, it is not always possible.

We cannot assume that all the possible bugs can be eventually fixed. Some bugs can be fixed, pretty easily and quickly, but some others cannot. Mainly mainly because they rely on, they require redesign of a certain component. And in that case, the, of course, it, let's say the company responsible for the redesign can have some, some issues. And in terms of time, but also resources that need to be used.

So it is not, we should not assume that every time the bugs that are found can be eventually fixed because they require different set of resources and capabilities, and that might happen that might also happen that sometimes some bugs are not even fixed due to this reason. So that's basically all in terms of classes of vulnerabilities, and, that can be, that can be used by an attacker. And next lectures, we're going to describe the possible defense mechanism provided by Google.