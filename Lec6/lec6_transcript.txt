
Welcome everyone to this new lecture of the mobile security course. Today, we're gonna see how in another application is compiled from the source code until it becomes an APK file and how it is executed on an Android device. So first of all, let's discuss about the schema. As you know, you when you develop an Android application, you can either rely on the Java programming language or on the Kotlin programming language. But you can also rely on, what is called the native code, which involves either c or c plus plus programming languages.

Usually, you rely on native code to develop your your own application when you want to achieve a very high performance. For example, gaming applications are, usually developed both with, Java or Kotlin and with CC plus plus code. The completion procedure procedure for these 2 programming languages is, pretty different. So you can see here that on the left, we have that, whatever is the programming language that you use for the compete for writing your code, whether it is Java or Kotlin, the, first step involves a Java compiler, a standard JavaScript compiler that, compiles this source code into Java bytecode, which means that we have for every, dot Java class, the, associated the dot class Java bytecode. And all the, possible files that are dot class, that ends with a dot class are compressed into a single dot jar file.

So this intermediate Java vertical representation can be already executed by a Java a standard Java virtual machine. However, we have to, think about the different context execution environment which comes with an a mobile device. So as we already mentioned several times, even when we introduced the, the difference between the Android operating system with respect to the, for example, the Linux one, even though Android is an extension or, is a Linux based system, we saw that there are several different several features that are different on, when you have to execute an operating system on a mobile device with respect to, for example, a laptop or, a traditional computer. In this case, it is pretty much the same. So when we have to, execute an application, we actually have keep in mind that we are going to execute it on a mobile device, which comes with, certain restrictions or hardware limitations.

For so for this for this reason, the, original developers of the system, decided to introduce a new virtual machine, which is an evolution of the Java virtual machine, and it is called the Dalvik virtual machine. So, basically, we move from what is a traditional Java virtual machine towards a Dalvik virtual machine in order to have better performance when we want to execute the, byte code or generally speaking in another application in a mobile device. There is also another reason for, moving from a Java virtual machine towards a double liquid machine, which is, more or less for compatibility issues. So the, Dalvik both the Java bytecode, so the Java bytecode is executed in a Java virtual machine, and, respectively, the Dalvik bytecode is executed in a Dalvik virtual machine. The let's say that the original need for, the Android developers to go for, a virtual machine environment for executing another application is that, this allows, the developers to develop a single APK file, which can be executed on any mobile, on any mobile device without considering the underlying architecture despite some, very specific features.

But generally speaking, if you develop an APK file with, the standard APIs from the Android framework, you can, you can assume that you can run this APK file without considering the underlying architecture. This is achieved thanks to the without the crystal machine, which is instead already embedded in the, Android operating system, and that is hardly dependent from the underlying architecture. So let's say that the dependency from from the underlying architecture is implemented within the Adobe peripheral machine. While on the contrary, the code that you can route that you have to write in your own application is not dependent from the underlying architecture. So you can write, whatever code you want from the standard Android API framework, and you can be sure that this will be executed.

Of course, this is a general rule. There are some specific features, for example, the target, SDK or other specific features that, an application might be depend from that might not be available on certain devices or that can be different from device to device. But generally speaking, this is a, rule that, works. So the let's say, need for a virtual machine is for dependency reasons. We can write code that is not dependent from the underlying architecture and the need for moving, for moving from a Java virtual machine towards a data virtual machine is for performance issues.

So we are running in those applications on a on a mobile device, and we need something that is high performant. So when you compile your source code, the, Java the the final code that you will, have is public bytecode. And the extension of all the classes is, or let's say all the, all the generated bytecode comes compressed into a single dot index file. To be more precise, nowadays, we have, applications that are getting more and more complex. So, in the design, you, were very likely to to have a single dex file dot dex file within each single APK file.

Nowadays, when you, if you open if you unpacked an APK file, it is very likely that you're going to find several dot text files. Anyway, the general completion procedure is pretty much the same. So at the end, we will have 1 or more dot x dot x files within the APK file itself. On the other side, the completion procedure that involves the native code, c or c plus plus is, different because in this case, instead, we are we have a dependency from the underlying architecture. And, the final output of the completion of the completion procedure is the standard shared object file, which comes with NSO f extension.

So the 2, procedures are, different. And, we also have we will have a lecture about the how to write native code in Android. And this is, specifically useful to to be reminded when you have to analyze another application. So we will see that for the, that is generated from Java or Kotlin. We can have the, we can somehow replicate the, procedure on the other way around.

So from the, we can recover this original source code, but, the procedure for, retrieving the original c or c plus plus code source code from the machine code is much, much more difficult even if, even sometime sometimes even even impossible. So it really depends from the complexity of the native code itself. So far, we will discuss about this procedure, which is of course more common, but we will also see, how the native code affects the reverse engineering procedure. So far, I've just I've been just discussing about, the source code, but you should remember or you should have, questioned yourself about resources and about manifest file, which are additional files that, of course, are part of an APK file. So in order to have a big picture about, the work procedure, that involves the compilation and the execution, this is the an overview that provides you, all the different steps.

So, the schema that I've just presented refers to this, first step. So from the school from the source code, what is the output of the compilation, which is, in in case of Android, a text file. As soon as we have a final, dot x file or several dot x files, we also have to we still have to generate the final p k file. And this final procedure is, the one that is shown here. So, basically, the both the resources and the native code that at this point is, has been already compiled, and it is provided as a shared object are zipped into a single PK file.

So we have the first step, which is this compilation from the Java up to, We have, in a different process, the compilation from the native code into the final shared object. And at the end, we will have, the compression of all these different files into a single APK file. As soon as the, APK files is stored on the is downloaded and installed on, on an Android device, then we know that the another party system will be involved into the installation procedure. So far, we've been discussing about how the, Android OS and also the installation of an APK file in terms of assigning a new user identifier or preparing the memory so that there is a dedicated private directory for that new application. But, right now, we are going to discuss about the underlying process that involves the APK file itself.

So the first step is basically to do the to follow the reverse procedure that we have seen so far. So the APK file is splitted or unpacked into its original deck, file or files and into its original resources and empty code. And then we have here 2 different situations according to the, runtime execution environment. So on the left, we have the target virtual machine, while on the right, we have the art runtime execution environment. We will see, what's the difference between the 2, but, basically, the Dalvik virtual machine was the execution environment up to Android 4.4, while art is the execution environment that we have nowadays.

So when we, retrieve the text file, this is basically further, optimized in order to be executed at run time into different, through 2 different procedures. So in the dynamic with the machine, the optimization this optimization procedure, ended up with the generation of a Nautex file through the dex OPT, compiler. On the other side, on art, these, optimization comes towards the generation of an f an f file, which contains both, decks and also native code. The resources and the native code here are, let's say, split it and, like, handled in a different way because the native code will be executed as a native, of course, within the native code execution environment, while the, resources are part of the, overall execution environment, whether it is or. And, they will be involved, eventually at runtime.

Finally, we have to keep in mind that, we have always to keep in mind that the Android applications by themselves cannot be executed because they are unable to do anything without the, surrounding without the Android framework KPI. So that's why we have also the that can be, that, of course, are invoked at runtime. So, right now, what we've been what we have seen so far is that we actually have, again, this sandbox model that applies, of course, that is already, involved during the installation of, the application. And that, of course, is, even much more involved during the execution of the application itself. Just as a reminder, the sandbox is basically a process installation procedure that involves, that allows the Android operating system to keep every application separated all the applications are separated from each other.

And, actually, the Dolby Griffin machine in the first original Android versions and the art execution environment in the newest one in the newer ones are, the representation, the real implementation of the sandbox itself. So one possible, let's say, like, error in, as an assumption is that since everything is run and executed in a virtual machine, then, it is by assumption secure. This is definitely not true because, unfortunately, there are several ways for an attacker to, let's say, to break or to, bypass this, this countermeasure that is provided by the, sandbox itself. Of course, we will see them later. So this is the big picture, and we will see, right now a little bit, we will provide here several information about this valid bytecode.

So as I said, valid bytecode is a sort of, optimized Java bytecode. There are, let's say, the general structure could be similar, but there are some differences that, we're going to do right now. So, as you can see here, the, this is an example of a valid bytecode. We have, basically that for every method, we have an association of the method with what is called the register frame, which is what you see here. So this is just the target bytecode associated with the full method that is a method of the belonging to the, type of class.

Target bytecode is a register based language or representation. So we have registers, and such registers are used for saving the data, for sending arguments to during the invocation of our method or for retrieving the the result. And what is cool about the the public part of it does is that it does actually, a reference, or it is able to represent the classes and the methods and the fields as well as the object instances. So it has also some building types such as void by the char integer or bullion. And it has this syntax that is, let's say destination to source, syntax, which means that whenever you have these, like, the first register will be the destination, while the first one is the source of the information.

So for example, here, we have that, v one is, the, let's say, the register that will, save the, final result of this summary between these 2, registers, tarv3 and b 0, probably, for sure contain 2 integer numbers. The panels that would, be saved into the v one register. So let's, try to discuss a little bit more about, details about this language. It is not important, of course, to know everything. I just want to give you a general overview and the general feeling about what is, what this valid code involves.

So as I said, first of all, it is registered based. When you disassemble an application, which means that from the Dalvik bytecode, you try to from the compressed Dalvik bytecode, you you retrieve the original Dalvik bytecode. You will see that for every class, there is every class in the original source code is associated to a smiley a single smiley file. So, for example, if we have the pepper class such as this one, which comes with 2 different, methods, one that is, assisted for an instance and one that is static, we will have that the associated smiley file is, singularly associated to the paper class. So for every class, we have a smiley file.

And, as I said, for every method, we have the registered frame. So for example, if we have the if we want to consider the pick method, which is, instance dependent, we will have the following frame. So, of course, here we have the argument type and the return, value type, which are both integers. We have the definition of the amount of registers that we need in this case, which is 3 because, we have the x value. We have, the return value, which will be so the x value is saved into v 2 register.

We have the return value, which is, saved into the v zero register. But we also have the 3rd register that is the one containing the instance of the class. So whenever we have a method that is non static, the first register will always contain a reference to the this object, where this means the instance of the object on top of which this method is called. This is a non static method, so we need, of course, we we need as many, registers as the arguments, as the variables that we need inside the logic of the method itself, but also an additional register which is used for saving this reference. So a reference to the current instance on top of which the the register has been called.

So let's see the difference with respect to, for example, static method, which is the full one. So 4 is a static method, again, associated to the, belonging to the pepper class. So as we said, the pepper class will have its own smiley file, and within that file, we will see as many registers frame register frames as many methods the pepper class has. So this is the register frame of the full method. We have, once again, the, the 2 different, arguments, which are an integer and, a peppa, a peppa an instance of the pepper class, and then we have the return value tag, which is an integer.

In this case, we have 4 different registers. We will see how those, they are used. So the first instruction is the following one. So we have to work on top of the p, argument, the, pick method that is that requires the a argument. So this is pretty straightforward because we see that, on top of the paper instance, which is, p, we work the pig method with an integer, which will return another integer.

And the reference for this is that we need the, basically, the a value, which is an argument, and it comes with the v three register. So a is saved into the v three register, while the instance p, which is also an argument, comes with the v four register. So, invoked means that on top of the v four instance, we invoke the pick method, which will receive the v three content of the register. Move result is a direct instruction that moves the that actually saves the result of this invocation, which in this case is the b value, an integer, into the register v zero. At the end, we have this return instruction that comes with the also, an addition between the two values.

So once again, we have that the in this case, the return value or the result of the, this operation will be saved into the v one register. And that a, we know that he's already saved into the v three register, will be summed with the v zero register here and, eventually returned by through the return instruction, which will return the final result in containing the d one register. So, at first, it sounds a little bit, like, it requires a little bit of attention, of course, because register basis, a register based language. But then if you start reading, start reading a bit of public output, it should be it should become more, should become easier to to understand the raw logic. So, information the language is that we have several instructions that are already somehow built in and are provided by the Dalvik white code language itself.

So for example, we can have the definition of context, constants, and the association or the moving, or let's say, transfer of our constant value into a register. So always remember that the syntax is the solution to sources. So that means that since the source, this is the original value that will be saved into the p five register. And, yeah, so these are the possible Arabic instructions we can perform. We have already some math related built in operations.

So for example, the if we want to, add 2 different values or if we want to multiply 2 different values or to divide different values, those are the set of instructions. On the other side, we can also have, we we, of course, have some instructions that allow to, represent the method invocation, which could be different according to the kind of, method that we are invoking. So if we have a method that is, that is not static or static, it really it, depends, and we have a separate, Dalvik instruction associated to the invocation, we can, as I said, retrieve the return value that comes after the invocation of a valid instruction through the move result instructions. So if you perform, a valid instruction and you want to retrieve the return value to just invoke the move result, and then you will save the output into different register. We also have, and getter, instructions for, retrieving the values from the field cell within a class.

And we also have instructions for, creating a new instance of an object. It is also possible to represent even, eventually, conditional or control flow direction. So, for example, if then else, the if then else statements and so forth. So, given this, let's say, very brief introduction to the codec bytecode. Right now, we have to figure out how is it possible to, actually execute such, such code.

So as I told you, and as was already shown in the big picture that I, you said before, we have basically, s history in the, execution environment for the Android application that comes with 2, important points. So the first part, as well as I said, the first Android versions up until 4.4, were used to have this data driven machine. Between 4 Android 4.4 and Android 7, we have, we had a switch from the Dalvik virtual machine towards the Android runtime environment, and, that came with some features. And then from Android 7, up until today, we have still the end of the time environment, but with, let's say, different features in terms of, execution of Android applications. So let's try to summarize.

So in the first hundred versions, as I said, there was double the machine. And, the core, let's say, the core information that you have to keep in mind about the the original version of the w piece machine is that it used to have the just in time compilation. So just in time means that you are going to compile, the direct pipe code into machine code only when the, the code is going to be used. So at run time, on demand, when the code is, then when the code is compiled, it is going to be cached, somewhere on the on the device. But, the very first time that is invoked, you're going to you need to compile.

As a matter of fact, as you have seen, the valid bytecode is just an intermediate representation. So, of course, we cannot execute the bytecode on the Android devices. Somehow, we still have to, compile it from the bytecode into the binary code, which is eventually, the one that will be executed on the Android device. So with the machine, the core point with comes with the just in time computation. That means that you compile only, when the make the method is invoked.

Of course, this comes with some limitations because, that, of course, affect the, runtime execution of an application because the combination is executed at runtime. So it means that you can, you can have you can see, like, a slower performance from the so, given that this just in time computational was not effective, it was not performant, from Android 4.4, Google decided to move from this machine to a new execution environment, which is called Android runtime or, let us say, ART. So ART replaced the old NVIDIAV virtual machine, and it originally came with this ahead of time compilation. Ahead of time is completely the opposite from the just in time compilation because it compiles it means that it compiles the whole bytecode into the machine code during the installation procedure of the application itself. Of course, the switch of this, completion procedure or completion time frame introduced some benefits, but on your side, there were also some So the pros, is that with R to the, runtime execution and also the boot were much faster because everything was already compiled and, ready for being executed on the other device.

But on the other side, compiling, everything from scratch and doing the installation means that you need a lot of space, and the installation takes especially if system up upgrades. So when you had the, in this in that versions, after, let's say, after Android 4.4, but for sure, after Android 5 because in Android 4.4, art was, introduced as, in, like, as a first, beta release, but it was definitely, it has definitely replaced the network with machine only after 105. So in these versions, the, system update was pretty pretty slow because, it was very slow because you had to, like, if you when you update the underlying operating system, it means that you're going to update all the, you're going to, like, reinstall all the different APK files and all the different applications. So since, Art came with the ahead of time compilation, when you had to update the operating system, you had to re, redo all the computation for all the applications that were installed, and that could take really quite a time. So finally, in Android 7, Google switched to what is, right now still the, like, the execution environment for another application, which is also the, best from a performance point of view because it is a comp because this is a trade off between just in time compilation and ahead of time compilation.

And the reasoning behind the, deciding whether to compile a method at at installation time or at run time is done according to, the definition of these hot methods. So a hot method is basically a method that is very likely to be invoked at run time. And, it is, it can be identified as such by inspecting, some features of, some inner features of the class itself. And, so the classes of the framework, but, for example, have associated with this hot hot counter, and the highest is the hot counter. The also, the higher is this, hot counter.

The higher is also the probability with which the, class will be executed. So if I know by assumption that our class is, really very likely to be executed, then it is better to have it compiled during the installation of the application itself. On the other side, if I have a class that maybe will be called sometimes during the execution of an of an app, it doesn't really matter if I, compile it during the installation, so I can compile it during the execution of the app itself. Just to give you an example, a method that is, defined as a hot method is a start activity. So start activity is a method that it is very likely to be executed at runtime.

So when an application is installed to the device, the the activity class, will be for sure compiled so that it will be already available, during the execution of the application itself. On the other side, for example, the custom code that is designed by the developers is not, known by assumption, and it is not possible to, to know whether it will be hot or not. So very likely, the overall rule is that there are some classes of the Android framework that are marked as hot methods, and, they will be compiled through the ahead of time computation, while there are some other classes of the framework or, custom classes from the developers that will be very likely, compiled through adjusting time compilation. So thanks to this trade off, we will have, let's say, both crossing cost from the the 2 different and this is a big picture or, an overview of the situation. So with the there is no performance Speed, like, the runtime speed.

But on the other side, we, do not have any, impact on the installation procedure or on the system upgrade or even on the amount of memory used. On the other side, the height of time is completely is you can see from this table is definitely complementary because you have, a very fast boot procedure as well as very fast run time execution application. But on the other side, you have a slower, you have slower performance in terms of, during installation, maybe the system upgrade, and also during, in terms of, amount of RAM that you can, require on the underlying Android operating system. So the solution, the final solution that Google came up with is this trade off, which is pretty cool and pretty useful because it combines, all the, like, as I said, all the benefits and the, so all the cons and cons of the 2 different approaches. One last mention is about, the optimization that is performed during the installation procedure.

So remember in during the p in the big picture, we saw that when you when the dex file is extracted from the APK file, we have we have a further, optimization procedure that is different between the, data machine and the art and the art execution environment. So for the Dalvik virtual machine, we had we used to have this dex opt, which, optimized the original dex file into an index file. And this index file was, an additional file state with, together with the APK file. So somehow it was optimization, but, that was supposed to, like, to to improve the boot procedure of some application, for example, the system apps. But, of course, it also, had some it also required a lot of me, Arthur.

The situation is a little bit more complex because we have different formats. We both have the art format and the OAuth file, format. So let's say that the, all the files that come with the dot art extension refer to pre initialized classes or, objects while the OAT files are eventually the, like, the new format for the previous OATX files. So, basically, these WAD files at the end of the day are also, further wrapped into an alpha file. But, at the end of the day, they, are just, an improvement and optimize the, text file.

So the text file is optimized into, you know, file through the text tool. So, yeah, the format is so what we have by the end of the at the end of the day, in the what is called the, Android runtime environment. So we have, different files. As I said, whatever comes with the art, dot art extension, it refers to pre initialize the class and then classes and objects. So in the art environment, we will have this boot dot art file, which contains the pre initialize the classes and objects from the Android framework.

On the other side, we will have the boot dot file that contains the precompiled inform, the most important precompiled classes from the, framework. So that is basically the, boot dot org is the output of what is the, ahead of time compilation. So well, where all the, hot methods and classes will be pre compiled in order to be already available during their entire execution of another application. So, this is overall the, big picture about what you can find. And an additional note is about how the, original process is actually generated when an application is installed.

Well, there is also these, let's say, additional information or this additional design choice, which is, the following one. So in Android, we have, that when the device is booted, there is, this zigot process that is created. And the zigot process is like the master or the, parent for all the other processes, that are going to execute on the, other applications. So whenever you run, whenever you install and run and then write up, the process, that is responsible for executing such another application has been for the by has been for the from the zigod process. So, basically, if you kill the zigod process, nothing will be executed anymore and everything crashes because we don't have the, parent, process anymore.

And somehow we can associate the zigot process as the, for the Android, operating system.