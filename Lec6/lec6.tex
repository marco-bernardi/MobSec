\documentclass{article}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{geometry}

\title{Mobile Security Course}
\author{}
\date{}

\begin{document}

\maketitle

\section{Compilation and Execution of Android Applications}

\subsection{Languages for Android Development}
Android applications can be developed using:
\begin{itemize}
    \item \textbf{Java or Kotlin}: These languages are often used for their ease of integration with the Android framework.
    \item \textbf{Native Code (C/C++)}: Native code is commonly used to achieve high performance, particularly in gaming applications.
\end{itemize}

\subsection{Compilation Process}
The compilation process differs between Java/Kotlin and native code.

\subsubsection{Java/Kotlin Compilation}
The process for Java/Kotlin involves:
\begin{itemize}
    \item A Java compiler compiles the source code into Java bytecode.
    \item Each \texttt{.java} class file is converted into a \texttt{.class} file containing Java bytecode.
    \item All \texttt{.class} files are compressed into a single \texttt{.jar} file.
\end{itemize}

\subsubsection{Mobile Device Constraints}
Android applications are designed with mobile-specific constraints, such as limited hardware capabilities, in mind. For this reason, Android developers chose to utilize a custom virtual machine known as the \textbf{Dalvik Virtual Machine}.

\subsection{Dalvik Virtual Machine (DVM) and Compatibility}
The Dalvik Virtual Machine, as an evolution of the Java Virtual Machine (JVM), provides improved performance for mobile devices.

\subsubsection{Reasons for the Dalvik VM}
\begin{itemize}
    \item \textbf{Performance}: The DVM is optimized to execute bytecode on mobile hardware efficiently.
    \item \textbf{Compatibility}: A single APK can run across various device architectures without modification, thanks to the abstraction provided by the Dalvik VM.
\end{itemize}

\subsubsection{Dalvik Bytecode}
Java bytecode is executed within the JVM, while Dalvik bytecode is run on the DVM. This abstraction enables developers to build applications that are independent of the underlying architecture, except in specific cases where certain features may vary across devices.

\section{Generating the APK File}
\subsection{Bytecode and DEX Files}
After compiling Java/Kotlin code:
\begin{itemize}
    \item The Java bytecode is transformed into Dalvik bytecode, resulting in a \texttt{.dex} (Dalvik Executable) file.
    \item Modern applications often contain multiple \texttt{.dex} files due to the increasing complexity of apps.
\end{itemize}

\subsection{Native Code Compilation}
The compilation of C/C++ code differs from Java/Kotlin:
\begin{itemize}
    \item Native code is architecture-dependent, resulting in a \texttt{.so} (shared object) file for each supported architecture.
    \item Native code dependencies introduce additional complexities in reverse engineering.
\end{itemize}

\subsection{Final APK Assembly}
The final APK file is generated by combining:
\begin{itemize}
    \item \textbf{DEX files}: These contain the Dalvik bytecode.
    \item \textbf{Native Libraries}: Architecture-specific \texttt{.so} files.
    \item \textbf{Resources and Manifest}: Additional files required by the application, such as images and configuration data.
\end{itemize}

All of these components are compressed into a single APK file.

\section{Reverse Engineering Android Applications}
\subsection{Java/Kotlin Code}
Reverse engineering Java/Kotlin code is possible by decompiling DEX files, allowing the retrieval of source code with relative ease.

\subsection{Native Code}
Native code, however, is more challenging to reverse engineer:
\begin{itemize}
    \item Recovering the original C/C++ source code from machine code is often difficult, and sometimes impossible.
    \item The complexity of native code can hinder reverse engineering, especially for applications prioritizing security and performance.
\end{itemize}

\subsection{Additional Considerations}
Beyond the source code, APK files contain resources and the manifest file, which play a crucial role in understanding the application’s structure.

\section{Compilation and Execution Workflow Summary}
The workflow for compiling and executing an Android application can be summarized as follows:
\begin{itemize}
    \item \textbf{Compilation of Source Code}: Java/Kotlin source code is compiled into DEX files; C/C++ code is compiled into \texttt{.so} files.
    \item \textbf{Final APK Creation}: DEX files, native libraries, and resources are compressed into an APK file.
    \item \textbf{Execution on Android Device}: The Dalvik VM enables compatibility across various device architectures, facilitating the execution of the APK on any compatible Android device.
\end{itemize}

\section{APK Installation on Android}
After an APK file is compiled, packaged, and installed on an Android device, the Android OS:
\begin{itemize}
    \item Assigns the application a unique user ID.
    \item Sets up a private directory in memory specific to the application.
\end{itemize}

The APK is then unpacked, splitting it into:
\begin{itemize}
    \item Original DEX files
    \item Resources
    \item Native code files
\end{itemize}

At this stage, the application is ready for execution, following one of two paths depending on the runtime environment.

\section{Runtime Environments: Dalvik and ART}
There are two main execution environments in Android:
\begin{itemize}
    \item \textbf{Dalvik Virtual Machine (VM):} Used up to Android 4.4.
    \item \textbf{Android Runtime (ART):} Used in newer versions of Android.
\end{itemize}

In Dalvik, the DEX file is dynamically optimized to produce an ODEX (Optimized DEX) file. With ART, the optimization generates an ELF (Executable and Linkable Format) file, which combines DEX and native code for more efficient execution.

\section{Sandboxing and Security}
Android applications operate in a \textbf{sandboxed} environment, which isolates each application, enhancing security:
\begin{itemize}
    \item \textbf{Dalvik VM and ART} act as intermediaries in code execution, isolating applications from each other.
    \item However, sandboxing does not ensure complete security, as attackers may still find ways to bypass these protections.
\end{itemize}

\section{Dalvik Bytecode Structure}
Dalvik bytecode is a \textbf{register-based language}, optimized for mobile environments. This structure uses registers for data storage, argument passing, and return value retrieval during method calls.

\subsection{Class and Method Representation}
Each class in Dalvik bytecode corresponds to a Smali file, which contains:
\begin{itemize}
    \item A \textbf{register frame} for each method, allocating registers for method arguments, instance references, and internal variables.
    \item Non-static methods have an additional register for the \texttt{this} reference (the current instance).
\end{itemize}

\subsection{Static vs Non-Static Methods}
In Dalvik bytecode:
\begin{itemize}
    \item \textbf{Non-static methods} require a reference to the object instance, stored in a register.
    \item \textbf{Static methods} do not need an instance reference, as they operate independently of any specific object.
\end{itemize}

\section{Dalvik Bytecode Syntax}
Dalvik bytecode, used by the Dalvik Virtual Machine (DVM) in Android, follows a \textbf{destination-to-source syntax}. This means that each instruction specifies a destination register (where the result is stored) followed by the source registers (which contain the data being operated upon). The general structure of a Dalvik instruction is:

\begin{itemize}
    \item The first register is the destination, which will hold the result of the operation.
    \item The following registers are the source operands that provide the data needed for the operation.
\end{itemize}

This syntax enables a clean, readable format for specifying operations, and helps simplify the task of translating higher-level Java code into bytecode. A key point of Dalvik's design is to optimize space and execution speed, which is achieved by making the bytecode instructions compact and efficient.

For example, consider the addition operation:

\begin{itemize}
    \item Suppose we have three registers, \texttt{p0}, \texttt{p1}, and \texttt{p2}.
    \item If the instruction is \texttt{add p0, p1, p2}, it means that the value in \texttt{p1} is added to the value in \texttt{p2}, and the result is stored in \texttt{p0}.
\end{itemize}

This destination-to-source structure ensures that the Dalvik bytecode is both efficient and easy to understand, with each instruction clearly specifying the operation and its operands.

\subsection{Example: Invoking a Method}
In Dalvik bytecode, method invocations follow a similar pattern. The arguments for the method are first placed in registers, and the method is invoked. After the method execution, the result (if any) is stored in a designated register for further use. Here's a breakdown of this process:

\begin{itemize}
    \item The arguments to the method are first moved to the appropriate registers, based on the method signature.
    \item The method is then invoked using an instruction like \texttt{invoke-virtual} or \texttt{invoke-static}, depending on whether the method is non-static or static.
    \item If the method returns a value, it is stored in the register specified by the \texttt{move-result} instruction.
\end{itemize}

For instance, if you want to invoke a method that takes two integers and returns an integer, the code would look like:

\begin{itemize}
    \item \texttt{const/4 p0, 10} (loads the first argument into register \texttt{p0})
    \item \texttt{const/4 p1, 20} (loads the second argument into register \texttt{p1})
    \item \texttt{invoke-static {p0, p1}, Lcom/example/Math;->add(II)I} (invokes the static method \texttt{add}, passing \texttt{p0} and \texttt{p1} as arguments)
    \item \texttt{move-result p2} (moves the result of the method into register \texttt{p2})
\end{itemize}

This example demonstrates how method invocation works in Dalvik bytecode, with arguments being passed through registers, the method being called, and the result being retrieved from the return value.

\section{Built-in Instructions in Dalvik Bytecode}
Dalvik bytecode includes a rich set of built-in instructions that make it a versatile language for Android application development. These instructions range from basic arithmetic and memory manipulation to more advanced operations like method invocation and exception handling. Familiarity with Dalvik's instructions can help developers understand how Android applications are executed at the bytecode level.

Some of the important categories of instructions include:
\begin{itemize}
    \item Arithmetic instructions for operations such as addition, subtraction, multiplication, and division.
    \item Memory operations like loading and storing data into registers.
    \item Control flow instructions such as \texttt{if-then-else}, loops, and exception handling.
    \item Method invocation instructions for calling static and non-static methods.
    \item Object manipulation instructions like creating new instances and accessing fields.
\end{itemize}

Understanding these instructions provides insights into how Android applications are executed, which is essential for both developers and reverse engineers.

\section{Constants and Registers in Dalvik Bytecode}
Dalvik bytecode operates with constants and registers to store and manipulate data. Constants can be either literal values or predefined symbols, such as strings or numbers, which are loaded into registers before being used in operations.

\begin{itemize}
    \item \textbf{Registers}: These are temporary storage locations used to hold data while the bytecode executes. For example, the register \texttt{p0} might hold an integer value, and \texttt{p1} might hold a string.
    \item \textbf{Constants}: Constants are values that remain unchanged throughout the execution of the program. They can be directly loaded into registers or used in computations.
\end{itemize}

A typical example of working with constants and registers in Dalvik bytecode:

\begin{itemize}
    \item \texttt{const/4 p0, 10} (loads the constant 10 into register \texttt{p0}).
    \item \texttt{const-string p1, "Hello, world!"} (loads a constant string into register \texttt{p1}).
\end{itemize}

In this example, two constants (an integer and a string) are loaded into registers to be used later in the bytecode.

\section{Arithmetic Instructions}
Dalvik bytecode includes a variety of instructions for performing arithmetic operations. These instructions are optimized for the hardware and are fundamental for performing calculations within Android applications. The common arithmetic operations include:

\begin{itemize}
    \item \textbf{Addition}: The \texttt{add} instruction adds the values of two source registers and stores the result in the destination register.
    \item \textbf{Subtraction}: The \texttt{sub} instruction subtracts the value in the second register from the first and stores the result in the destination register.
    \item \textbf{Multiplication}: The \texttt{mul} instruction multiplies two values and stores the result.
    \item \textbf{Division}: The \texttt{div} instruction divides one value by another and stores the result.
\end{itemize}

For example:

\begin{itemize}
    \item \texttt{add p0, p1, p2} (adds the values in \texttt{p1} and \texttt{p2}, stores the result in \texttt{p0}).
    \item \texttt{mul p3, p4, p5} (multiplies the values in \texttt{p4} and \texttt{p5}, stores the result in \texttt{p3}).
\end{itemize}

These arithmetic instructions allow the Dalvik Virtual Machine to perform calculations on the fly, supporting a wide range of operations within Android applications.

\section{Method Invocation Instructions}
Method invocation in Dalvik bytecode is handled by specific instructions that vary depending on whether the method being invoked is static or non-static. The most commonly used instructions for method invocation are:

\begin{itemize}
    \item \textbf{invoke-virtual}: Used to invoke an instance (non-static) method. The first argument is the object reference, followed by any other arguments.
    \item \textbf{invoke-static}: Used to invoke a static method. This does not require an object reference, only the method's arguments.
    \item \textbf{move-result}: This instruction is used to move the result of a method invocation into a register for further use.
\end{itemize}

For example:

\begin{itemize}
    \item \texttt{invoke-virtual {p0}, Lcom/example/SomeClass;->methodName()V} (invokes a non-static method on the object in register \texttt{p0}).
    \item \texttt{invoke-static {p1, p2}, Lcom/example/Math;->add(II)I} (invokes a static method \texttt{add}, passing registers \texttt{p1} and \texttt{p2} as arguments).
\end{itemize}

The \texttt{move-result} instruction is used to retrieve the return value of the method:

\begin{itemize}
    \item \texttt{move-result p3} (stores the result of the method in register \texttt{p3}).
\end{itemize}

\section{Object and Control Flow Instructions}
Dalvik bytecode also includes instructions for creating objects and controlling the flow of execution. Some of the important instructions in this category include:

\begin{itemize}
    \item \textbf{New instance}: The \texttt{new-instance} instruction creates a new object instance, allocating memory for it.
    \item \textbf{Getter}: Instructions like \texttt{iget} and \texttt{iget-object} are used to access fields in an object (for example, retrieving a variable value from a class).
    \item \textbf{Control Flow}: Instructions like \texttt{if-eq} and \texttt{goto} allow developers to control the program flow, enabling conditional execution and loops.
\end{itemize}

For instance:

\begin{itemize}
    \item \texttt{new-instance p0, Lcom/example/MyClass;} (creates a new instance of \texttt{MyClass} and stores it in \texttt{p0}).
    \item \texttt{iget p1, p0, Lcom/example/MyClass;->fieldName:I} (retrieves the field \texttt{fieldName} from the object in \texttt{p0} and stores it in \texttt{p1}).
    \item \texttt{if-eq p1, p2, label} (if the values in \texttt{p1} and \texttt{p2} are equal, jump to the specified label).
\end{itemize}

These instructions allow developers to create dynamic Android applications that can respond to different inputs and conditions in real time.


\section{Dalvik Bytecode Execution Environments}
The evolution of Android's execution environment includes three main phases, each with unique characteristics.

\subsection{Dalvik Virtual Machine (up to Android 4.4)}
Dalvik VM employed \textbf{just-in-time (JIT) compilation}, where:
\begin{itemize}
    \item Bytecode is converted to machine code at runtime, only when code is required.
    \item Compiled code is cached on the device.
\end{itemize}
Although this approach saves storage, it results in slower runtime performance due to on-demand compilation.

\subsection{Android Runtime (ART) (from Android 4.4 to Android 7)}
ART introduced \textbf{ahead-of-time (AOT) compilation}, compiling bytecode to machine code during application installation. This approach:
\begin{itemize}
    \item Improves runtime performance by pre-compiling code
    \item Reduces boot time and increases execution speed
    \item Requires more storage space and longer installation time, especially for system updates
\end{itemize}
By Android 5.0, ART completely replaced Dalvik, leading to noticeable speed improvements but increased storage requirements.

\subsection{Hybrid Compilation (Android 7 and later)}
In Android 7, Google introduced a hybrid approach that balances JIT and AOT compilation:
\begin{itemize}
    \item \textbf{Hot methods} (methods frequently invoked at runtime) are identified by a \texttt{hot counter}.
    \item Frequently executed methods are compiled during installation, while others compile at runtime.
\end{itemize}
This strategy minimizes the overhead of AOT compilation while retaining JIT’s flexibility, offering the best performance balance.

\section{Introduction to Hot Methods and Compilation Trade-offs}
Android's compilation strategy distinguishes between methods based on their likelihood of execution:
\begin{itemize}
    \item \textbf{Hot methods} (e.g., \texttt{startActivity}) are likely to be executed frequently. These are compiled during installation, ready for use at runtime.
    \item Custom code, which is unpredictable in usage, may not be compiled ahead of time, relying instead on \textit{just-in-time (JIT)} compilation.
\end{itemize}
This trade-off balances runtime speed and memory requirements by pre-compiling Android framework classes while delaying compilation of custom or less critical classes.

\section{Performance Implications of Compilation Strategies}
The trade-off between JIT and \textit{ahead-of-time (AOT)} compilation has distinct performance impacts:
\begin{itemize}
    \item AOT compilation offers faster boot and runtime execution but can slow installation and system updates.
    \item JIT compilation reduces installation and memory demands, though it may slightly affect runtime speed.
\end{itemize}
Google’s hybrid solution leverages the advantages of both JIT and AOT compilation, optimizing Android’s performance by pre-compiling essential methods while minimizing installation overhead for custom code.

\section{Optimization Procedures During Installation}
When an Android application installs, optimization processes differ between Dalvik and Android Runtime (ART):
\begin{itemize}
    \item In Dalvik, the \texttt{dexopt} tool optimizes the \texttt{dex} files, creating an additional \texttt{odex} file for faster booting.
    \item In ART, a complex system of file formats supports optimization:
    \begin{itemize}
        \item Files with the \texttt{.art} extension contain pre-initialized classes and objects.
        \item \texttt{OAT} files store optimized, precompiled versions of classes.
        \item Additional \texttt{odex} files wrap these files for further efficiency.
    \end{itemize}
\end{itemize}

\section{ART Boot Files and Precompiled Classes}
The Android Runtime environment utilizes specific files during boot:
\begin{itemize}
    \item \texttt{boot.art}: Contains pre-initialized classes and objects from the Android framework.
    \item \texttt{boot.oat}: Includes the essential, precompiled classes, which are a result of AOT compilation and are readily available during app execution.
\end{itemize}

\section{The Zygote Process}
\subsection{Initialization}
When an Android device boots, the Zygote process is launched first. It serves as the “master” process for all other app processes. The Zygote process initializes shared resources and loads commonly used libraries, including Android framework classes. This allows apps to start more quickly.

\subsection{Forking}
When a new application is launched, the Zygote process "forks" itself, creating a new process for the app. The new process inherits the resources and loaded classes from Zygote, allowing the app to launch faster because it doesn’t need to reload common resources.

\subsection{Importance of Zygote}
The Zygote process is central to Android's process management. If the Zygote process is killed, no other app can run, and the system effectively crashes because all other processes are derived from it. Therefore, the Zygote process is considered the parent process of all Android applications.

\section{Android Output Files}
During the installation and execution of Android apps, several output files are generated that aid in optimizing performance.

\subsection{DEX Files}
\textbf{DEX} (Dalvik Executable) files contain the bytecode of an Android application. These files are included in the APK (Android Package) file. Originally, these files were processed by the Dalvik Virtual Machine (DVM), but since Android 5.0, they are processed by the Android Runtime (ART).

\subsection{DEXOPT in Dalvik}
In the Dalvik environment, the \texttt{dexopt} tool was used to optimize the original DEX files into ODex (Optimized DEX) files. These ODex files were stored alongside the APK and were designed to speed up the boot process, particularly for system apps. However, this approach required additional memory resources.

\subsection{ART and Optimization}
With the Android Runtime (ART), the optimization process is more efficient:
\begin{itemize}
    \item \textbf{ART Format}: ART uses files with the \texttt{.art} extension, which are generated after ahead-of-time (AOT) compilation. In AOT compilation, bytecode is converted into machine code before the app runs.
    \item \textbf{OAT Files}: The \texttt{OAT} (Optimized Android Executable) files replace the ODex format. These OAT files store optimized machine code generated by AOT compilation.
\end{itemize}

\subsection{Precompiled Files}
Two key files are involved in ART optimization:
\begin{itemize}
    \item \textbf{boot.art}: This file contains pre-initialized classes and objects from the Android framework. These are critical for the system’s performance and are available at runtime.
    \item \textbf{boot.oat}: This file contains precompiled classes, similar to \texttt{boot.art}, and is crucial for the Android framework. It’s created during installation and used throughout the app’s execution.
\end{itemize}

\subsection{Alpha and Wrapping of Output Files}
After optimization, the final output files are wrapped into optimized formats, such as \texttt{.oat} and \texttt{.art}. These formats ensure that both the Android system and apps run efficiently with minimal installation overhead and memory usage.

\end{document}
